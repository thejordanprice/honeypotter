<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSH Honeypot</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        #map {
            height: 400px;
            width: 100%;
            border-radius: 0.5rem;
        }
        .location-popup {
            font-size: 14px;
            line-height: 1.4;
        }
        /* Core dark mode theme configuration */
        .dark body { background-color: rgb(17, 24, 39); }
        .dark nav { background-color: rgb(31, 41, 55); }
        .dark h1, .dark h2 { color: rgb(255, 255, 255); }
        .dark .bg-white { background-color: rgb(31, 41, 55); }
        .dark .text-gray-800 { color: rgb(243, 244, 246); }
        .dark .text-gray-600 { color: rgb(209, 213, 219); }
        .dark .bg-gray-50 { background-color: rgb(55, 65, 81); }
        .dark .hover\:bg-gray-100:hover { background-color: rgb(75, 85, 99); }
        .dark .border-gray-200 { border-color: rgb(75, 85, 99); }

        /* Smooth transitions for theme switching */
        * {
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Dark mode color scheme overrides */
        .dark body { 
            background-color: #1a1a1a;
            transition: background-color 0.3s ease;
        }
        .dark .bg-white { 
            background-color: #2d2d2d !important;
            transition: background-color 0.3s ease;
        }
        .dark .bg-gray-100 { 
            background-color: #1a1a1a !important;
            transition: background-color 0.3s ease;
        }
        .dark .bg-gray-50 { 
            background-color: #3d3d3d !important;
            transition: background-color 0.3s ease;
        }
        .dark .text-gray-800 { 
            color: #f3f4f6 !important;
            transition: color 0.3s ease;
        }
        .dark .text-gray-600 { 
            color: #d1d5db !important;
            transition: color 0.3s ease;
        }
        .dark .border-gray-200 { 
            border-color: #4b5563 !important;
            transition: border-color 0.3s ease;
        }
        .dark .shadow { 
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.3s ease;
        }
        .dark .hover\:bg-gray-100:hover { 
            background-color: #4b5563 !important;
            transition: background-color 0.3s ease;
        }

        /* Dark mode text and interactive elements */
        .dark * { color: #f3f4f6; }
        .dark svg { color: #f3f4f6; }
        .dark a { color: #60a5fa; }
        .dark a:hover { color: #93c5fd; }
        .dark input::placeholder { color: #9ca3af; }
        
        /* Semantic color preservation */
        .dark .text-red-600 { color: #dc2626 !important; }
        .dark .text-green-600 { color: #059669 !important; }
        
        /* Form elements dark mode styling */
        .dark input, 
        .dark select { 
            background-color: #3d3d3d !important;
            color: #f3f4f6 !important;
            border-color: #4b5563 !important;
        }
        .dark button:not(#darkModeToggle) {
            background-color: #3d3d3d !important;
            color: #f3f4f6 !important;
        }
        .dark button:not(#darkModeToggle):hover {
            background-color: #4b5563 !important;
        }
        .dark #attempts > div {
            background-color: #3d3d3d !important;
        }
        .dark #attempts > div:hover {
            background-color: #4b5563 !important;
        }

        /* Chart component dark mode adjustments */
        .dark .chart-container {
            color: #f3f4f6;
        }

        /* Leaflet map controls dark mode preservation */
        .dark .leaflet-control-zoom a,
        .dark .leaflet-control-zoom-in,
        .dark .leaflet-control-zoom-out,
        .dark .leaflet-control * {
            color: #000 !important;
            background-color: #fff !important;
        }
        
        .dark .leaflet-control-zoom a:hover,
        .dark .leaflet-control-zoom-in:hover,
        .dark .leaflet-control-zoom-out:hover {
            background-color: #f4f4f4 !important;
        }
        
        .dark .leaflet-control-attribution {
            color: #000 !important;
            background-color: rgba(255, 255, 255, 0.8) !important;
        }
        
        .dark .leaflet-control-attribution a {
            color: #0078A8 !important;
        }

        /* Dark mode map tile styling */
        .dark-tiles {
            filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
        }

        /* Responsive layout adjustments */
        @media (max-width: 768px) {
            .chart-container {
                height: 250px;
            }
            
            #map {
                height: 300px;
            }
            
            .container {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }
            
            nav .container {
                max-width: 100%;
            }

            /* Chart text size optimization for mobile */
            .chart-js-render-monitor {
                font-size: 12px;
            }
        }

        /* Small device breakpoint utilities */
        @media (min-width: 640px) {
            .sm\:inline {
                display: inline;
            }
        }

        /* Connection status indicator dark mode preservation */
        .dark #connectionStatusContainer,
        .dark #connectionStatus,
        .dark #connectionStatusIcon {
            color: inherit !important;
            background-color: inherit !important;
        }

        .dark #connectionStatusContainer.bg-red-100 {
            background-color: rgb(254, 226, 226) !important;
        }

        .dark #connectionStatusContainer.bg-green-100 {
            background-color: rgb(220, 252, 231) !important;
        }

        .dark #connectionStatus.text-red-600,
        .dark #connectionStatusIcon.text-red-600 {
            color: rgb(220, 38, 38) !important;
        }

        .dark #connectionStatus.text-green-600,
        .dark #connectionStatusIcon.text-green-600 {
            color: rgb(5, 150, 105) !important;
        }

        /* Map popup dark mode styling */
        .dark .leaflet-popup-content-wrapper {
            background-color: #374151;
            color: #f3f4f6;
        }

        .dark .leaflet-popup-tip {
            background-color: #374151;
        }

        .dark .location-popup strong {
            color: #60a5fa;
        }

        .dark .leaflet-container a.leaflet-popup-close-button {
            color: #f3f4f6;
        }

        .dark .leaflet-container a.leaflet-popup-close-button:hover {
            color: #60a5fa;
        }
    </style>
</head>
<body class="bg-gray-100">
    <nav class="bg-white dark:bg-gray-800 shadow-lg mb-8">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <h1 class="text-xl font-semibold text-gray-800">SSH Honeypot</h1>
                    <div class="ml-4 px-3 py-1 rounded-full" id="connectionStatusContainer">
                        <!-- Status elements for connection state display -->
                        <span id="connectionStatus" class="hidden sm:inline"></span>
                        <svg id="connectionStatusIcon" class="w-4 sm:hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M12 5l7 7-7 7"/>
                        </svg>
                    </div>
                </div>
                <div class="flex items-center gap-4">
                    <div class="p-2 w-[88px] rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center">
                        <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                        </svg>
                        <span id="totalAttempts" class="font-semibold">0</span>
                    </div>
                    <div class="p-2 w-10 h-10 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center cursor-pointer" id="exportIPs">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                    </div>
                    <button id="darkModeToggle" class="p-2 w-10 h-10 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center">
                        <svg id="lightIcon" class="w-5 h-5 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <svg id="darkIcon" class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 pb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4">Attack Origins</h2>
            <div id="map"></div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Attack Distribution</h2>
                <div class="chart-container">
                    <canvas id="attemptsChart"></canvas>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Top Usernames</h2>
                <div class="chart-container">
                    <canvas id="usernamesChart"></canvas>
                </div>
            </div>
        </div>

        <div class="bg-white dark:bg-gray-800 rounded-lg shadow">
            <div class="p-4 border-b border-gray-200">
                <h2 class="text-xl font-semibold">Recent Login Attempts</h2>
            </div>
            <div class="p-4">
                <div class="flex flex-col sm:flex-row items-center gap-4 mb-4">
                    <div class="w-full sm:w-2/3">
                        <input type="text" id="searchInput" placeholder="Search..." 
                               class="w-full px-4 py-2 border rounded-lg">
                    </div>
                    <div class="w-full sm:w-1/3 flex flex-col sm:flex-row gap-4">
                        <div class="w-full sm:w-1/2">
                            <select id="filterSelect" class="w-full px-4 py-2 border rounded-lg">
                                <option value="all">All Time</option>
                                <option value="lastHour">Last Hour</option>
                                <option value="today">Today</option>
                                <option value="thisWeek">This Week</option>
                            </select>
                        </div>
                        <div class="w-full sm:w-1/2">
                            <select id="protocolSelect" class="w-full px-4 py-2 border rounded-lg">
                                <option value="all">All Protocols</option>
                                <option value="ssh">SSH Only</option>
                                <option value="telnet">Telnet Only</option>
                                <option value="ftp">FTP Only</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="attempts" class="space-y-4"></div>
                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <div class="text-sm text-gray-600 order-2 sm:order-1">
                        Showing <span id="startRange">0</span>-<span id="endRange">0</span> of <span id="totalItems">0</span> attempts
                    </div>
                    <div class="flex space-x-2 order-1 sm:order-2">
                        <button id="prevPage" class="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Previous
                        </button>
                        <button id="nextPage" class="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Next
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="bg-white dark:bg-gray-800 shadow-lg mt-8 py-4">
        <div class="container mx-auto px-4 text-center text-gray-600">
            made with ❤️ by <a href="https://github.com/thejordanprice" class="text-blue-600 hover:text-blue-800 transition-colors" target="_blank">thejordanprice</a>
        </div>
    </footer>

    <script>
        // Initialize theme based on user preference or system settings
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
            document.getElementById('lightIcon').classList.remove('hidden');
            document.getElementById('darkIcon').classList.add('hidden');
        }

        // Handle dark mode toggle and update all UI components
        document.getElementById('darkModeToggle').addEventListener('click', () => {
            const isDark = document.documentElement.classList.toggle('dark');
            document.getElementById('lightIcon').classList.toggle('hidden');
            document.getElementById('darkIcon').classList.toggle('hidden');
            localStorage.theme = isDark ? 'dark' : 'light';
            
            // Update map theme
            setMapTheme(isDark);

            // Re-trigger connection status update to refresh colors
            const currentStatus = document.getElementById('connectionStatus').textContent;
            const isError = currentStatus.includes('error') || currentStatus.includes('closed');
            updateConnectionStatus(currentStatus, isError);

            // Update chart colors
            const chartTextColor = isDark ? '#f3f4f6' : '#1f2937';
            const gridColor = isDark ? '#374151' : '#e5e7eb';
            
            // Update attempts chart colors
            attemptsChart.options.scales.x.ticks.color = chartTextColor;
            attemptsChart.options.scales.y.ticks.color = chartTextColor;
            attemptsChart.options.scales.x.grid.color = gridColor;
            attemptsChart.options.scales.y.grid.color = gridColor;
            attemptsChart.data.datasets[0].backgroundColor = isDark ? 'rgba(96, 165, 250, 0.7)' : 'rgb(56, 189, 248)';
            attemptsChart.data.datasets[1].backgroundColor = isDark ? 'rgba(59, 130, 246, 0.7)' : 'rgb(37, 99, 235)';
            attemptsChart.data.datasets[2].backgroundColor = isDark ? 'rgba(16, 185, 129, 0.7)' : 'rgb(16, 185, 129)';
            attemptsChart.options.plugins.legend.labels = { color: chartTextColor };
            attemptsChart.update();

            // Update usernames chart colors
            usernamesChart.options.scales.x.ticks.color = chartTextColor;
            usernamesChart.options.scales.y.ticks.color = chartTextColor;
            usernamesChart.options.scales.x.grid.color = gridColor;
            usernamesChart.options.scales.y.grid.color = gridColor;
            usernamesChart.data.datasets[0].backgroundColor = isDark ? 'rgba(96, 165, 250, 0.7)' : 'rgb(56, 189, 248)';
            usernamesChart.data.datasets[1].backgroundColor = isDark ? 'rgba(59, 130, 246, 0.7)' : 'rgb(37, 99, 235)';
            usernamesChart.data.datasets[2].backgroundColor = isDark ? 'rgba(16, 185, 129, 0.7)' : 'rgb(16, 185, 129)';
            usernamesChart.options.plugins.legend.labels = { color: chartTextColor };
            usernamesChart.update();
        });

        // Initialize map with light/dark theme support
        const map = L.map('map').setView([20, 0], 2);
        let currentTileLayer;

        const lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        });

        const darkTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            className: 'dark-tiles'
        });

        // Function to set the appropriate tile layer
        function setMapTheme(isDark) {
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }
            currentTileLayer = isDark ? darkTileLayer : lightTileLayer;
            currentTileLayer.addTo(map);
        }

        // Initial theme setup
        setMapTheme(document.documentElement.classList.contains('dark'));

        // Store map markers to prevent duplicate markers at same location
        const markers = new Map();

        function updateMap(attempt) {
            if (attempt.latitude && attempt.longitude) {
                const key = `${attempt.latitude},${attempt.longitude}`;
                let marker = markers.get(key);
                
                if (!marker) {
                    marker = {
                        leaflet: L.marker([attempt.latitude, attempt.longitude]),
                        attempts: new Set()
                    };
                    markers.set(key, marker);
                    marker.leaflet.addTo(map);
                }

                marker.attempts.add(attempt);
                
                const location = [
                    attempt.city,
                    attempt.region,
                    attempt.country
                ].filter(Boolean).join(', ');

                const popupContent = `
                    <div class="location-popup">
                        <strong>${location}</strong><br>
                        Total Attempts: ${marker.attempts.size}<br>
                        Latest: ${attempt.username}@${attempt.client_ip}
                    </div>
                `;
                
                marker.leaflet.bindPopup(popupContent);
            }
        }

        const attemptsDiv = document.getElementById("attempts");
        const searchInput = document.getElementById("searchInput");
        const filterSelect = document.getElementById("filterSelect");
        const protocolSelect = document.getElementById("protocolSelect");
        const connectionStatus = document.getElementById("connectionStatus");
        let attempts = [];
        let socket = null;

        function updateConnectionStatus(status, isError = false) {
            const container = document.getElementById('connectionStatusContainer');
            const statusText = document.getElementById('connectionStatus');
            const statusIcon = document.getElementById('connectionStatusIcon');
            
            statusText.textContent = status;
            
            // Use darker background colors for better contrast
            const isDarkMode = document.documentElement.classList.contains('dark');
            const bgColor = isError 
                ? (isDarkMode ? 'bg-red-200' : 'bg-red-100')
                : (isDarkMode ? 'bg-green-200' : 'bg-green-100');
            
            const textColor = isError 
                ? (isDarkMode ? 'text-red-800' : 'text-red-600')
                : (isDarkMode ? 'text-green-800' : 'text-green-600');
            
            container.className = `ml-4 px-3 py-1 rounded-full ${bgColor}`;
            statusText.className = `hidden sm:inline ${textColor}`;
            statusIcon.className = `w-4 sm:hidden ${textColor}`;
            
            if (status.includes('Connected')) {
                statusIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>';
            } else if (status.includes('Connecting')) {
                statusIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>';
            } else {
                statusIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>';
            }
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            updateConnectionStatus('Connecting to WebSocket...');
            
            socket = new WebSocket(wsUrl);

            socket.onopen = function() {
                updateConnectionStatus('Connected to WebSocket');
                fetch('/api/attempts')
                    .then(response => response.json())
                    .then(data => {
                        attempts = data;
                        attempts.forEach(updateMap);
                        updateUI();
                        updateCharts();
                    });
            };

            socket.onmessage = function(event) {
                try {
                    const attempt = JSON.parse(event.data);
                    attempts.unshift(attempt);
                    updateMap(attempt);
                    updateUI();
                    updateCharts();
                } catch (error) {
                    console.error('Error processing message:', error);
                }
            };

            socket.onerror = function(error) {
                updateConnectionStatus('WebSocket error: ' + error.message, true);
                console.error('WebSocket error:', error);
            };

            socket.onclose = function() {
                updateConnectionStatus('WebSocket connection closed. Reconnecting...', true);
                setTimeout(connectWebSocket, 5000);
            };
        }

        function formatDateToLocalTime(isoString) {
            // Ensure proper UTC timestamp parsing for consistent timezone handling
            const date = new Date(isoString + 'Z');
            
            return date.toLocaleString(undefined, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            });
        }

        function createAttemptElement(attempt) {
            const location = [
                attempt.city,
                attempt.region,
                attempt.country
            ].filter(Boolean).join(', ');

            return `
                <div class="bg-gray-50 rounded-lg p-4 hover:bg-gray-100 transition-colors">
                    <div class="flex flex-col sm:flex-row justify-between gap-2">
                        <span class="font-semibold break-all">
                            ${attempt.username}@${attempt.client_ip}
                            <span class="inline-block px-2 py-1 text-xs rounded-full ml-2">
                                ${attempt.protocol.toUpperCase()}
                            </span>
                        </span>
                        <span class="text-gray-500 text-sm">${formatDateToLocalTime(attempt.timestamp)}</span>
                    </div>
                    <div class="text-gray-600 mt-2">
                        <div class="break-all">Password: ${attempt.password}</div>
                        ${location ? `<div class="text-sm mt-1">Location: ${location}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function filterAttempts(attempts) {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filterValue = filterSelect.value;
            const protocolValue = protocolSelect.value;
            const now = new Date();

            return attempts.filter(attempt => {
                const matchesSearch = searchTerm === '' || 
                    attempt.username.toLowerCase().includes(searchTerm) ||
                    attempt.client_ip.includes(searchTerm) ||
                    attempt.password.toLowerCase().includes(searchTerm);

                const matchesProtocol = protocolValue === 'all' || attempt.protocol === protocolValue;

                // Create date object from UTC timestamp
                const timestamp = new Date(attempt.timestamp + 'Z');
                let matchesFilter = true;

                switch (filterValue) {
                    case 'lastHour':
                        matchesFilter = (now - timestamp) <= (60 * 60 * 1000);
                        break;
                    case 'today':
                        // Compare using local dates
                        const attemptDate = new Date(timestamp.toLocaleDateString());
                        const todayDate = new Date(now.toLocaleDateString());
                        matchesFilter = attemptDate.getTime() === todayDate.getTime();
                        break;
                    case 'thisWeek':
                        const weekAgo = new Date(now);
                        weekAgo.setDate(now.getDate() - 7);
                        matchesFilter = timestamp >= weekAgo;
                        break;
                    case 'all':
                    default:
                        matchesFilter = true;
                        break;
                }

                return matchesSearch && matchesFilter && matchesProtocol;
            });
        }

        let currentPage = 1;
        const itemsPerPage = 10;

        function updateUI() {
            const filteredAttempts = filterAttempts(attempts);
            const totalItems = filteredAttempts.length;
            
            // Update total attempts in navbar
            document.getElementById('totalAttempts').textContent = attempts.length;
            
            // Calculate pagination
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
            
            // Update pagination display
            document.getElementById('startRange').textContent = totalItems ? startIndex + 1 : 0;
            document.getElementById('endRange').textContent = endIndex;
            document.getElementById('totalItems').textContent = totalItems;
            
            // Update pagination buttons
            document.getElementById('prevPage').disabled = currentPage === 1;
            document.getElementById('nextPage').disabled = endIndex >= totalItems;
            
            // Display paginated results
            const paginatedAttempts = filteredAttempts.slice(startIndex, endIndex);
            attemptsDiv.innerHTML = paginatedAttempts
                .map(attempt => createAttemptElement(attempt))
                .join('');
        }

        // Add pagination event listeners
        document.getElementById('prevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                updateUI();
            }
        });

        document.getElementById('nextPage').addEventListener('click', () => {
            const filteredAttempts = filterAttempts(attempts);
            const totalPages = Math.ceil(filteredAttempts.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                updateUI();
            }
        });

        // Modify existing event listeners to reset pagination
        searchInput.addEventListener('input', () => {
            currentPage = 1;
            updateUI();
        });
        
        filterSelect.addEventListener('change', () => {
            currentPage = 1;
            updateUI();
        });

        protocolSelect.addEventListener('change', () => {
            currentPage = 1;
            updateUI();
        });

        // Initialize chart configurations with responsive design
        const attemptsChart = new Chart(
            document.getElementById('attemptsChart'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'SSH',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark') 
                                ? 'rgba(96, 165, 250, 0.7)' // Light blue for dark mode
                                : 'rgb(56, 189, 248)', // Sky blue for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'Telnet',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(59, 130, 246, 0.7)' // Darker blue for dark mode
                                : 'rgb(37, 99, 235)', // Deep blue for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'FTP',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(16, 185, 129, 0.7)' // Green for dark mode
                                : 'rgb(16, 185, 129)', // Green for light mode
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            stacked: true,
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false
                        }
                    }
                }
            }
        );

        const usernamesChart = new Chart(
            document.getElementById('usernamesChart'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'SSH',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(96, 165, 250, 0.7)' // Light blue for dark mode
                                : 'rgb(56, 189, 248)', // Sky blue for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'Telnet',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(59, 130, 246, 0.7)' // Darker blue for dark mode
                                : 'rgb(37, 99, 235)', // Deep blue for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'FTP',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(16, 185, 129, 0.7)' // Green for dark mode
                                : 'rgb(16, 185, 129)', // Green for light mode
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            stacked: true,
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            }
        );

        // Process and display hourly login attempt statistics
        function updateCharts() {
            if (attempts.length === 0) return;

            // Get current hour in local time
            const now = new Date();
            const currentHour = now.getHours();

            // Create arrays for the last 12 hours
            const hourlyDataSSH = new Array(12).fill(0);
            const hourlyDataTelnet = new Array(12).fill(0);
            const hourlyDataFTP = new Array(12).fill(0);
            const hourLabels = new Array(12).fill('').map((_, i) => {
                const hour = (currentHour - 11 + i + 24) % 24;
                const displayHour = hour % 12 || 12;
                const ampm = hour >= 12 ? 'PM' : 'AM';
                return `${displayHour}${ampm}`;
            });

            // Count attempts for each hour using local time
            attempts.forEach(attempt => {
                // Create date object from UTC timestamp
                const date = new Date(attempt.timestamp + 'Z');
                const attemptHour = date.getHours();
                
                // Calculate how many hours ago this attempt was in local time
                let hoursAgo = (currentHour - attemptHour + 24) % 24;
                
                // Only count if it's within the last 12 hours
                if (hoursAgo < 12) {
                    const index = 11 - hoursAgo;
                    if (attempt.protocol === 'ssh') {
                        hourlyDataSSH[index]++;
                    } else if (attempt.protocol === 'telnet') {
                        hourlyDataTelnet[index]++;
                    } else if (attempt.protocol === 'ftp') {
                        hourlyDataFTP[index]++;
                    }
                }
            });

            // Update the attempts chart
            attemptsChart.data.labels = hourLabels;
            attemptsChart.data.datasets[0].data = hourlyDataSSH;
            attemptsChart.data.datasets[1].data = hourlyDataTelnet;
            attemptsChart.data.datasets[2].data = hourlyDataFTP;
            attemptsChart.update();

            // Update username distribution chart
            const usernameData = {};
            attempts.forEach(attempt => {
                if (!usernameData[attempt.username]) {
                    usernameData[attempt.username] = { ssh: 0, telnet: 0, ftp: 0 };
                }
                if (attempt.protocol === 'ssh') {
                    usernameData[attempt.username].ssh++;
                } else if (attempt.protocol === 'telnet') {
                    usernameData[attempt.username].telnet++;
                } else if (attempt.protocol === 'ftp') {
                    usernameData[attempt.username].ftp++;
                }
            });

            const topUsernames = Object.entries(usernameData)
                .sort((a, b) => (b[1].ssh + b[1].telnet + b[1].ftp) - (a[1].ssh + a[1].telnet + a[1].ftp))
                .slice(0, 5);

            usernamesChart.data.labels = topUsernames.map(([username]) => username);
            usernamesChart.data.datasets[0].data = topUsernames.map(([, counts]) => counts.ssh);
            usernamesChart.data.datasets[1].data = topUsernames.map(([, counts]) => counts.telnet);
            usernamesChart.data.datasets[2].data = topUsernames.map(([, counts]) => counts.ftp);
            usernamesChart.update();
        }

        // Initialize WebSocket connection for real-time updates
        connectWebSocket();

        // Expo
        document.getElementById('exportIPs').addEventListener('click', () => {
            // Open in new tab
            window.open('/api/export/ips', '_blank');
        });
    </script>
</body>
</html> 