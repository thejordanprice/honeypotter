<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honeypotter</title>
    <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="%23000000"><path d="M61.3 27.991c-.463-2.989-2.297-12.947-6.459-15.575c-.068-.042-.127-.081-.177-.114a9.687 9.687 0 0 0-.111-2.649C53.954 6.161 49.429 2 31.272 2C13.075 2 8.542 6.161 7.944 9.651a10.029 10.029 0 0 0-.127 2.641c-.064.05-.146.111-.251.186c-2.087 1.488-5.042 7.881-5.27 11.4c-.1 1.546.269 2.719 1.095 3.486c.103.096.216.17.326.253C2.861 29.897 2 32.961 2 36.075c0 4.122.866 7.474 4.245 11.08c3.377 3.606 3.028 3.36 3.377 5.114C9.974 54.023 12.745 62 31.247 62h.002c18.502 0 21.589-7.948 21.623-9.73c.027-1.354.435-2.12 1.408-3.204c.711.55 1.461.869 2.297.869c.678 0 1.672-.223 2.566-1.282c3.336-3.958 3.301-13.269 2.157-20.662M31.242 56.044c-13.896 0-21.681-5.621-21.681-6.133c0-.511 7.785 4.279 21.681 4.279c13.892 0 21.677-4.79 21.677-4.279c0 .512-7.785 6.133-21.677 6.133m26.421-8.64c-.347.412-.709.595-1.086.595c-3.079 0-7.105-12.257-11.436-12.257c-6.261 0-4.728-12.934-11.883-12.934c-1.926 0-10.222 6.403-12.778 6.403c-2.557 0-2.94-6.403-6.006-6.403c-3.717 0-6.51 3.61-8.609 3.61c-.412 0-.798-.139-1.159-.473c-1.891-1.755 2.148-10.584 3.983-11.891c1.835-1.311.667-1.182 1.162-4.075c.496-2.895 5.654-6.043 21.421-6.043c15.762 0 20.898 3.271 21.374 6.043c.495 2.894-.745 2.871 1.162 4.075c5.285 3.336 8.863 27.412 3.855 33.35" />
                        <path d="M31.249 16.766c-11.895 0-21.001-3.797-21.001-3.285c0 .513 9.106 4.892 21.001 4.892c11.893 0 21.001-4.379 21.001-4.892c0-.512-9.108 3.285-21.001 3.285" />
                        <path d="M16.614 9.664c2.648.987 8.198 1.667 14.635 1.667c6.438 0 11.987-.68 14.635-1.667c1.055-.395 1.662-.833 1.662-1.3c0-1.639-7.296-2.968-16.297-2.968c-9 0-16.296 1.329-16.296 2.968c0 .467.607.906 1.661 1.3" />
                    </svg>'>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        #map {
            height: 400px;
            width: 100%;
            border-radius: 0.5rem;
        }
        .location-popup {
            font-size: 14px;
            line-height: 1.4;
        }
        /* Core dark mode theme configuration */
        .dark body { background-color: rgb(17, 24, 39); }
        .dark nav { background-color: rgb(31, 41, 55); }
        .dark h1, .dark h2 { color: rgb(255, 255, 255); }
        .dark .bg-white { background-color: rgb(31, 41, 55); }
        .dark .text-gray-800 { color: rgb(243, 244, 246); }
        .dark .text-gray-600 { color: rgb(209, 213, 219); }
        .dark .bg-gray-50 { background-color: rgb(55, 65, 81); }
        .dark .hover\:bg-gray-100:hover { background-color: rgb(75, 85, 99); }
        .dark .border-gray-200 { border-color: rgb(75, 85, 99); }

        /* Smooth transitions for theme switching */
        * {
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        /* Dark mode color scheme overrides */
        .dark body { 
            background-color: #1a1a1a;
        }
        .dark .bg-white { 
            background-color: #2d2d2d !important;
        }
        .dark .bg-gray-100 { 
            background-color: #1a1a1a !important;
        }
        .dark .bg-gray-50 { 
            background-color: #3d3d3d !important;
        }
        .dark .text-gray-800 { 
            color: #f3f4f6 !important;
        }
        .dark .text-gray-600 { 
            color: #d1d5db !important;
        }
        .dark .border-gray-200 { 
            border-color: #4b5563 !important;
        }
        .dark .shadow { 
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3);
        }
        .dark .hover\:bg-gray-100:hover { 
            background-color: #4b5563 !important;
        }

        /* Dark mode text and interactive elements */
        .dark * { color: #f3f4f6; }
        .dark svg { color: #f3f4f6; }
        .dark a { color: #60a5fa; }
        .dark a:hover { color: #93c5fd; }
        .dark input::placeholder { color: #9ca3af; }
        
        /* Semantic color preservation */
        .dark .text-red-600 { color: #dc2626 !important; }
        .dark .text-green-600 { color: #059669 !important; }
        
        /* Form elements dark mode styling */
        .dark input, 
        .dark select { 
            background-color: #3d3d3d !important;
            color: #f3f4f6 !important;
            border-color: #4b5563 !important;
        }
        .dark button:not(#darkModeToggle) {
            background-color: #3d3d3d !important;
            color: #f3f4f6 !important;
        }
        .dark button:not(#darkModeToggle):hover {
            background-color: #4b5563 !important;
        }
        .dark #attempts > div {
            background-color: #3d3d3d !important;
        }
        .dark #attempts > div:hover {
            background-color: #4b5563 !important;
        }

        /* Chart component dark mode adjustments */
        .dark .chart-container {
            color: #f3f4f6;
        }

        /* Leaflet map controls dark mode preservation */
        .dark .leaflet-control-zoom a,
        .dark .leaflet-control-zoom-in,
        .dark .leaflet-control-zoom-out,
        .dark .leaflet-control * {
            color: #000 !important;
            background-color: #fff !important;
        }
        
        .dark .leaflet-control-zoom a:hover,
        .dark .leaflet-control-zoom-in:hover,
        .dark .leaflet-control-zoom-out:hover {
            background-color: #f4f4f4 !important;
        }
        
        .dark .leaflet-control-attribution {
            color: #000 !important;
            background-color: rgba(255, 255, 255, 0.8) !important;
        }
        
        .dark .leaflet-control-attribution a {
            color: #0078A8 !important;
        }

        /* Custom attribution styling */
        .leaflet-control-attribution {
            font-size: 8px !important;
            padding: 2px 4px !important;
            background-color: rgba(255, 255, 255, 0.7) !important;
        }

        .leaflet-control-attribution a {
            font-size: 8px !important;
        }

        /* Dark mode map tile styling */
        .dark-tiles {
            filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
        }

        /* Responsive layout adjustments */
        @media (max-width: 768px) {
            .chart-container {
                height: 250px;
            }
            
            #map {
                height: 300px;
            }
            
            .container {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }
            
            nav .container {
                max-width: 100%;
            }

            /* Chart text size optimization for mobile */
            .chart-js-render-monitor {
                font-size: 12px;
            }

            /* Mobile-specific optimizations */
            * {
                transition: background-color 0.15s ease-out, color 0.15s ease-out;
            }
        }

        /* Small device breakpoint utilities */
        @media (min-width: 640px) {
            .sm\:inline {
                display: inline;
            }
        }

        /* Connection status indicator dark mode preservation */
        .dark #connectionStatusContainer,
        .dark #connectionStatus,
        .dark #connectionStatusIcon {
            color: inherit !important;
            background-color: inherit !important;
        }

        .dark #connectionStatusContainer.bg-red-100 {
            background-color: rgb(254, 226, 226) !important;
        }

        .dark #connectionStatusContainer.bg-green-100 {
            background-color: rgb(220, 252, 231) !important;
        }

        .dark #connectionStatus.text-red-600,
        .dark #connectionStatusIcon.text-red-600 {
            color: rgb(220, 38, 38) !important;
        }

        .dark #connectionStatus.text-green-600,
        .dark #connectionStatusIcon.text-green-600 {
            color: rgb(5, 150, 105) !important;
        }

        /* Map popup dark mode styling */
        .dark .leaflet-popup-content-wrapper {
            background-color: #374151;
            color: #f3f4f6;
        }

        .dark .leaflet-popup-tip {
            background-color: #374151;
        }

        .dark .location-popup strong {
            color: #60a5fa;
        }

        .dark .leaflet-container a.leaflet-popup-close-button {
            color: #f3f4f6;
        }

        .dark .leaflet-container a.leaflet-popup-close-button:hover {
            color: #60a5fa;
        }

        /* Connection status indicator styles */
        #connectionStatusIndicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        #connectionStatusIndicator.connected {
            background-color: rgb(22, 163, 74);
        }

        #connectionStatusIndicator.reconnecting {
            background-color: rgb(234, 179, 8);
        }

        #connectionStatusIndicator.disconnected {
            background-color: rgb(220, 38, 38);
        }

        #connectionStatusIndicator svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        .dark #connectionStatusIndicator.connected {
            background-color: rgb(34, 197, 94);
        }

        .dark #connectionStatusIndicator.reconnecting {
            background-color: rgb(250, 204, 21);
        }

        .dark #connectionStatusIndicator.disconnected {
            background-color: rgb(239, 68, 68);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-100">
    <nav class="bg-white dark:bg-gray-800 shadow-lg mb-8">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <svg class="w-6 h-6 mr-2" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" stroke="none" fill="currentColor">
                        <path d="M61.3 27.991c-.463-2.989-2.297-12.947-6.459-15.575c-.068-.042-.127-.081-.177-.114a9.687 9.687 0 0 0-.111-2.649C53.954 6.161 49.429 2 31.272 2C13.075 2 8.542 6.161 7.944 9.651a10.029 10.029 0 0 0-.127 2.641c-.064.05-.146.111-.251.186c-2.087 1.488-5.042 7.881-5.27 11.4c-.1 1.546.269 2.719 1.095 3.486c.103.096.216.17.326.253C2.861 29.897 2 32.961 2 36.075c0 4.122.866 7.474 4.245 11.08c3.377 3.606 3.028 3.36 3.377 5.114C9.974 54.023 12.745 62 31.247 62h.002c18.502 0 21.589-7.948 21.623-9.73c.027-1.354.435-2.12 1.408-3.204c.711.55 1.461.869 2.297.869c.678 0 1.672-.223 2.566-1.282c3.336-3.958 3.301-13.269 2.157-20.662M31.242 56.044c-13.896 0-21.681-5.621-21.681-6.133c0-.511 7.785 4.279 21.681 4.279c13.892 0 21.677-4.79 21.677-4.279c0 .512-7.785 6.133-21.677 6.133m26.421-8.64c-.347.412-.709.595-1.086.595c-3.079 0-7.105-12.257-11.436-12.257c-6.261 0-4.728-12.934-11.883-12.934c-1.926 0-10.222 6.403-12.778 6.403c-2.557 0-2.94-6.403-6.006-6.403c-3.717 0-6.51 3.61-8.609 3.61c-.412 0-.798-.139-1.159-.473c-1.891-1.755 2.148-10.584 3.983-11.891c1.835-1.311.667-1.182 1.162-4.075c.496-2.895 5.654-6.043 21.421-6.043c15.762 0 20.898 3.271 21.374 6.043c.495 2.894-.745 2.871 1.162 4.075c5.285 3.336 8.863 27.412 3.855 33.35" />
                        <path d="M31.249 16.766c-11.895 0-21.001-3.797-21.001-3.285c0 .513 9.106 4.892 21.001 4.892c11.893 0 21.001-4.379 21.001-4.892c0-.512-9.108 3.285-21.001 3.285" />
                        <path d="M16.614 9.664c2.648.987 8.198 1.667 14.635 1.667c6.438 0 11.987-.68 14.635-1.667c1.055-.395 1.662-.833 1.662-1.3c0-1.639-7.296-2.968-16.297-2.968c-9 0-16.296 1.329-16.296 2.968c0 .467.607.906 1.661 1.3" />
                    </svg>
                    <h1 class="text-xl font-semibold text-gray-800">Honeypotter</h1>
                </div>
                <div class="flex items-center gap-4">
                    <div class="p-2 w-[88px] rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3V7M12 17V21M3 12H7M17 12H21M12 12H12.01M19 12C19 15.866 15.866 19 12 19C8.13401 19 5 15.866 5 12C5 8.13401 8.13401 5 12 5C15.866 5 19 8.13401 19 12Z"/>
                        </svg>
                        <span id="totalAttempts" class="font-semibold">0</span>
                    </div>
                    <div class="p-2 w-10 h-10 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center cursor-pointer" id="exportIPs">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                    </div>
                    <button id="darkModeToggle" class="p-2 w-10 h-10 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center">
                        <svg id="lightIcon" class="w-5 h-5 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <svg id="darkIcon" class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 pb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4">Attack Origins</h2>
            <div id="map"></div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Protocol Activity</h2>
                <div class="chart-container">
                    <canvas id="attemptsChart"></canvas>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Top Usernames</h2>
                <div class="chart-container">
                    <canvas id="usernamesChart"></canvas>
                </div>
            </div>
        </div>

        <div class="bg-white dark:bg-gray-800 rounded-lg shadow">
            <div class="p-4 border-b border-gray-200">
                <h2 class="text-xl font-semibold">Recent Login Attempts</h2>
            </div>
            <div class="p-4">
                <div class="flex flex-col sm:flex-row items-center gap-4 mb-4">
                    <div class="w-full sm:w-2/3">
                        <input type="text" id="searchInput" placeholder="Search..." 
                               class="w-full px-4 py-2 border rounded-lg">
                    </div>
                    <div class="w-full sm:w-1/3 flex flex-col sm:flex-row gap-4">
                        <div class="w-full sm:w-1/2">
                            <select id="filterSelect" class="w-full px-4 py-2 border rounded-lg">
                                <option value="all">All Time</option>
                                <option value="lastHour">Last Hour</option>
                                <option value="today">Today</option>
                                <option value="thisWeek">This Week</option>
                            </select>
                        </div>
                        <div class="w-full sm:w-1/2">
                            <select id="protocolSelect" class="w-full px-4 py-2 border rounded-lg">
                                <option value="all">All Protocols</option>
                                <option value="ssh">SSH Only</option>
                                <option value="telnet">Telnet Only</option>
                                <option value="ftp">FTP Only</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="attempts" class="space-y-4"></div>
                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <div class="text-sm text-gray-600 order-2 sm:order-1">
                        Showing <span id="startRange">0</span>-<span id="endRange">0</span> of <span id="totalItems">0</span> attempts
                    </div>
                    <div class="flex space-x-2 order-1 sm:order-2">
                        <button id="prevPage" class="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Previous
                        </button>
                        <button id="nextPage" class="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Next
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="bg-white dark:bg-gray-800 shadow-lg mt-8 py-4">
        <div class="container mx-auto px-4 text-center text-gray-600">
            made with ❤️ by <a href="https://github.com/thejordanprice" class="text-blue-600 hover:text-blue-800 transition-colors" target="_blank">thejordanprice</a>
        </div>
    </footer>

    <!-- Connection status indicator -->
    <div id="connectionStatusIndicator" class="connected">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
    </div>

    <script>
        // Initialize theme based on user preference or system settings
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
            document.getElementById('lightIcon').classList.remove('hidden');
            document.getElementById('darkIcon').classList.add('hidden');
        }

        // Handle dark mode toggle and update all UI components
        document.getElementById('darkModeToggle').addEventListener('click', () => {
            const isDark = document.documentElement.classList.toggle('dark');
            document.getElementById('lightIcon').classList.toggle('hidden');
            document.getElementById('darkIcon').classList.toggle('hidden');
            localStorage.theme = isDark ? 'dark' : 'light';
            
            // Update map theme
            setMapTheme(isDark);

            // Update chart colors based on theme
            const chartTextColor = isDark ? '#f3f4f6' : '#1f2937';
            const gridColor = isDark ? '#374151' : '#e5e7eb';
            
            // Update attempts chart colors
            attemptsChart.options.scales.x.ticks.color = chartTextColor;
            attemptsChart.options.scales.y.ticks.color = chartTextColor;
            attemptsChart.options.scales.x.grid.color = gridColor;
            attemptsChart.options.scales.y.grid.color = gridColor;
            attemptsChart.options.plugins.legend.labels.color = chartTextColor;
            attemptsChart.data.datasets[0].borderColor = isDark ? '#8b5cf6' : '#6d28d9';
            attemptsChart.data.datasets[1].borderColor = isDark ? '#3b82f6' : '#2563eb';
            attemptsChart.data.datasets[2].borderColor = isDark ? '#10b981' : '#059669';
            attemptsChart.update();

            // Update usernames chart colors
            usernamesChart.options.scales.x.ticks.color = chartTextColor;
            usernamesChart.options.scales.y.ticks.color = chartTextColor;
            usernamesChart.options.scales.x.grid.color = gridColor;
            usernamesChart.options.scales.y.grid.color = gridColor;
            usernamesChart.options.plugins.legend.labels.color = chartTextColor;
            usernamesChart.data.datasets[0].backgroundColor = isDark ? 'rgba(139, 92, 246, 0.8)' : 'rgba(109, 40, 217, 0.8)';
            usernamesChart.data.datasets[1].backgroundColor = isDark ? 'rgba(59, 130, 246, 0.8)' : 'rgba(37, 99, 235, 0.8)';
            usernamesChart.data.datasets[2].backgroundColor = isDark ? 'rgba(16, 185, 129, 0.8)' : 'rgba(5, 150, 105, 0.8)';
            usernamesChart.update();
        });

        // Initialize map with light/dark theme support
        const map = L.map('map').setView([20, 0], 2);
        let currentTileLayer;

        // Add this new function before the tileLayer definitions
        function centerMapOnMostActiveRegion(attempts) {
            if (!attempts || attempts.length === 0) return;

            // Create a grid to count attacks in different regions
            const grid = {};
            const validAttempts = attempts.filter(a => a.latitude && a.longitude);
            
            if (validAttempts.length === 0) return;

            // Round coordinates to create grid cells (1 degree resolution)
            validAttempts.forEach(attempt => {
                const lat = Math.round(attempt.latitude);
                const lng = Math.round(attempt.longitude);
                const key = `${lat},${lng}`;
                grid[key] = (grid[key] || 0) + 1;
            });

            // Find the cell with most attacks
            let maxCount = 0;
            let hotspotCenter = null;
            
            for (const [coords, count] of Object.entries(grid)) {
                if (count > maxCount) {
                    maxCount = count;
                    const [lat, lng] = coords.split(',').map(Number);
                    hotspotCenter = [lat, lng];
                }
            }

            // If we found a hotspot, center the map there with appropriate zoom
            if (hotspotCenter) {
                const zoom = window.innerWidth <= 768 ? 2 : 3; // Reduced zoom levels by 1
                map.setView(hotspotCenter, zoom, { animate: true });
            }
        }

        const lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        });

        const darkTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            className: 'dark-tiles'
        });

        // Function to set the appropriate tile layer
        function setMapTheme(isDark) {
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }
            currentTileLayer = isDark ? darkTileLayer : lightTileLayer;
            currentTileLayer.addTo(map);
        }

        // Initial theme setup
        setMapTheme(document.documentElement.classList.contains('dark'));

        // Store map markers to prevent duplicate markers at same location
        const markers = new Map();

        function updateMap(attempt) {
            if (attempt.latitude && attempt.longitude) {
                const key = `${attempt.latitude},${attempt.longitude}`;
                let marker = markers.get(key);
                
                if (!marker) {
                    marker = {
                        leaflet: L.marker([attempt.latitude, attempt.longitude]),
                        attempts: new Set()
                    };
                    markers.set(key, marker);
                    marker.leaflet.addTo(map);
                }

                // Create a unique key for each attempt using timestamp and IP
                const attemptKey = `${attempt.timestamp}_${attempt.client_ip}_${attempt.username}_${attempt.protocol}`;
                const previousSize = marker.attempts.size;
                marker.attempts.add(attemptKey);
                
                // Log if this was actually a new attempt
                if (marker.attempts.size > previousSize) {
                    console.log(`New unique attempt at ${key}: ${attemptKey}`);
                    console.log(`Location now has ${marker.attempts.size} unique attempts`);
                }
                
                const location = [
                    attempt.city,
                    attempt.region,
                    attempt.country
                ].filter(Boolean).join(', ');

                const popupContent = `
                    <div class="location-popup">
                        <strong>${location}</strong><br>
                        Total Attempts: ${marker.attempts.size}<br>
                        Latest: ${attempt.username}@${attempt.client_ip}
                    </div>
                `;
                
                marker.leaflet.bindPopup(popupContent);
            }
        }

        const attemptsDiv = document.getElementById("attempts");
        const searchInput = document.getElementById("searchInput");
        const filterSelect = document.getElementById("filterSelect");
        const protocolSelect = document.getElementById("protocolSelect");
        const connectionStatus = document.getElementById("connectionStatus");
        let attempts = [];
        let socket = null;

        function updateConnectionStatus(status, isError = false) {
            const indicator = document.getElementById('connectionStatusIndicator');
            const svg = indicator.querySelector('svg');
            
            if (status.includes('Connected')) {
                indicator.className = 'connected';
                svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>';
                svg.classList.remove('animate-spin');
            } else if (status.includes('Connecting')) {
                indicator.className = 'reconnecting';
                svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>';
                svg.classList.add('animate-spin');
            } else {
                indicator.className = 'disconnected';
                svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>';
                svg.classList.remove('animate-spin');
            }
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            updateConnectionStatus('Connecting to WebSocket...');
            
            socket = new WebSocket(wsUrl);

            socket.onopen = function() {
                updateConnectionStatus('Connected to WebSocket');
                fetch('/api/attempts')
                    .then(response => response.json())
                    .then(data => {
                        attempts = data;
                        attempts.forEach(updateMap);
                        updateUI();
                        updateVisualizations(attempts);
                        centerMapOnMostActiveRegion(attempts);
                    });
            };

            socket.onmessage = function(event) {
                try {
                    const attempt = JSON.parse(event.data);
                    attempts.unshift(attempt);
                    updateMap(attempt);
                    
                    // Only update UI with filtered data if it matches current filters
                    const currentFilters = {
                        search: searchInput.value.toLowerCase().trim(),
                        filter: filterSelect.value,
                        protocol: protocolSelect.value
                    };
                    
                    // Check if the new attempt matches current filters
                    const matchesSearch = currentFilters.search === '' || 
                        attempt.username.toLowerCase().includes(currentFilters.search) ||
                        attempt.client_ip.includes(currentFilters.search) ||
                        attempt.password.toLowerCase().includes(currentFilters.search);
                        
                    const matchesProtocol = currentFilters.protocol === 'all' || 
                        attempt.protocol === currentFilters.protocol;
                        
                    const timestamp = new Date(attempt.timestamp + 'Z');
                    const now = new Date();
                    let matchesFilter = true;
                    
                    switch (currentFilters.filter) {
                        case 'lastHour':
                            matchesFilter = (now - timestamp) <= (60 * 60 * 1000);
                            break;
                        case 'today':
                            const attemptDate = new Date(timestamp.toLocaleDateString());
                            const todayDate = new Date(now.toLocaleDateString());
                            matchesFilter = attemptDate.getTime() === todayDate.getTime();
                            break;
                        case 'thisWeek':
                            const weekAgo = new Date(now);
                            weekAgo.setDate(now.getDate() - 7);
                            matchesFilter = timestamp >= weekAgo;
                            break;
                    }

                    // Update total attempts counter regardless of filters
                    document.getElementById('totalAttempts').textContent = attempts.length;
                    
                    // Only update the UI if the new attempt matches current filters
                    if (matchesSearch && matchesProtocol && matchesFilter) {
                        currentPage = 1; // Reset to first page when new matching data arrives
                        const filteredAttempts = filterAttempts(attempts);
                        attemptsDiv.innerHTML = filteredAttempts
                            .slice(0, itemsPerPage)
                            .map(attempt => createAttemptElement(attempt))
                            .join('');
                            
                        // Update pagination info
                        const totalItems = filteredAttempts.length;
                        document.getElementById('startRange').textContent = totalItems ? 1 : 0;
                        document.getElementById('endRange').textContent = Math.min(itemsPerPage, totalItems);
                        document.getElementById('totalItems').textContent = totalItems;
                        document.getElementById('prevPage').disabled = true;
                        document.getElementById('nextPage').disabled = totalItems <= itemsPerPage;
                        
                        // Update visualizations with filtered data
                        updateVisualizations(filteredAttempts);
                    }
                } catch (error) {
                    console.error('Error processing message:', error);
                }
            };

            socket.onerror = function(error) {
                updateConnectionStatus('WebSocket error: ' + error.message, true);
                console.error('WebSocket error:', error);
            };

            socket.onclose = function() {
                updateConnectionStatus('WebSocket connection closed. Reconnecting...', true);
                setTimeout(connectWebSocket, 5000);
            };
        }

        function formatDateToLocalTime(isoString) {
            // Ensure proper UTC timestamp parsing for consistent timezone handling
            const date = new Date(isoString + 'Z');
            
            return date.toLocaleString(undefined, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            });
        }

        function createAttemptElement(attempt) {
            const location = [
                attempt.city,
                attempt.region,
                attempt.country
            ].filter(Boolean).join(', ');

            return `
                <div class="bg-gray-50 rounded-lg p-4 hover:bg-gray-100 transition-colors">
                    <div class="flex flex-col sm:flex-row justify-between gap-2">
                        <span class="font-semibold break-all">
                            ${attempt.username}@${attempt.client_ip}
                            <span class="inline-block px-2 py-1 text-xs rounded-full ml-2">
                                ${attempt.protocol.toUpperCase()}
                            </span>
                        </span>
                        <span class="text-gray-500 text-sm">${formatDateToLocalTime(attempt.timestamp)}</span>
                    </div>
                    <div class="text-gray-600 mt-2">
                        <div class="break-all">Password: ${attempt.password}</div>
                        ${location ? `<div class="text-sm mt-1">Location: ${location}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function filterAttempts(attempts) {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filterValue = filterSelect.value;
            const protocolValue = protocolSelect.value;
            const now = new Date();

            return attempts.filter(attempt => {
                const matchesSearch = searchTerm === '' || 
                    attempt.username.toLowerCase().includes(searchTerm) ||
                    attempt.client_ip.includes(searchTerm) ||
                    attempt.password.toLowerCase().includes(searchTerm);

                const matchesProtocol = protocolValue === 'all' || attempt.protocol === protocolValue;

                // Create date object from UTC timestamp
                const timestamp = new Date(attempt.timestamp + 'Z');
                let matchesFilter = true;

                switch (filterValue) {
                    case 'lastHour':
                        matchesFilter = (now - timestamp) <= (60 * 60 * 1000);
                        break;
                    case 'today':
                        // Compare using local dates
                        const attemptDate = new Date(timestamp.toLocaleDateString());
                        const todayDate = new Date(now.toLocaleDateString());
                        matchesFilter = attemptDate.getTime() === todayDate.getTime();
                        break;
                    case 'thisWeek':
                        const weekAgo = new Date(now);
                        weekAgo.setDate(now.getDate() - 7);
                        matchesFilter = timestamp >= weekAgo;
                        break;
                    case 'all':
                    default:
                        matchesFilter = true;
                        break;
                }

                return matchesSearch && matchesFilter && matchesProtocol;
            });
        }

        let currentPage = 1;
        const itemsPerPage = 10;

        function updateUI() {
            const filteredAttempts = filterAttempts(attempts);
            const totalItems = filteredAttempts.length;
            
            // Update total attempts in navbar
            document.getElementById('totalAttempts').textContent = attempts.length;
            
            // Calculate pagination
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
            
            // Update pagination display
            document.getElementById('startRange').textContent = totalItems ? startIndex + 1 : 0;
            document.getElementById('endRange').textContent = endIndex;
            document.getElementById('totalItems').textContent = totalItems;
            
            // Update pagination buttons
            document.getElementById('prevPage').disabled = currentPage === 1;
            document.getElementById('nextPage').disabled = endIndex >= totalItems;
            
            // Display paginated results
            const paginatedAttempts = filteredAttempts.slice(startIndex, endIndex);
            attemptsDiv.innerHTML = paginatedAttempts
                .map(attempt => createAttemptElement(attempt))
                .join('');

            // Update all visualizations with filtered data
            updateVisualizations(filteredAttempts);
        }

        // New function to update all visualizations with filtered data
        function updateVisualizations(filteredAttempts) {
            // Clear existing markers from the map
            markers.forEach(marker => {
                map.removeLayer(marker.leaflet);
            });
            markers.clear();

            // Update map with filtered attempts
            filteredAttempts.forEach(updateMap);
            centerMapOnMostActiveRegion(filteredAttempts);

            // Get current hour in local time
            const now = new Date();
            const currentHour = now.getHours();

            // Create arrays for the last 12 hours
            const hourlyDataSSH = new Array(12).fill(0);
            const hourlyDataTelnet = new Array(12).fill(0);
            const hourlyDataFTP = new Array(12).fill(0);
            const hourLabels = new Array(12).fill('').map((_, i) => {
                const hour = (currentHour - 11 + i + 24) % 24;
                const displayHour = hour % 12 || 12;
                const ampm = hour >= 12 ? 'PM' : 'AM';
                return `${displayHour}${ampm}`;
            });

            // Count attempts for each hour using local time
            filteredAttempts.forEach(attempt => {
                const date = new Date(attempt.timestamp + 'Z');
                const attemptHour = date.getHours();
                
                let hoursAgo = (currentHour - attemptHour + 24) % 24;
                
                if (hoursAgo < 12) {
                    const index = 11 - hoursAgo;
                    if (attempt.protocol === 'ssh') {
                        hourlyDataSSH[index]++;
                    } else if (attempt.protocol === 'telnet') {
                        hourlyDataTelnet[index]++;
                    } else if (attempt.protocol === 'ftp') {
                        hourlyDataFTP[index]++;
                    }
                }
            });

            // Update the attempts chart
            attemptsChart.data.labels = hourLabels;
            attemptsChart.data.datasets[0].data = hourlyDataSSH;
            attemptsChart.data.datasets[1].data = hourlyDataTelnet;
            attemptsChart.data.datasets[2].data = hourlyDataFTP;
            attemptsChart.update();

            // Update username distribution chart
            const usernameData = {};
            filteredAttempts.forEach(attempt => {
                if (!usernameData[attempt.username]) {
                    usernameData[attempt.username] = { ssh: 0, telnet: 0, ftp: 0 };
                }
                if (attempt.protocol === 'ssh') {
                    usernameData[attempt.username].ssh++;
                } else if (attempt.protocol === 'telnet') {
                    usernameData[attempt.username].telnet++;
                } else if (attempt.protocol === 'ftp') {
                    usernameData[attempt.username].ftp++;
                }
            });

            const topUsernames = Object.entries(usernameData)
                .sort((a, b) => (b[1].ssh + b[1].telnet + b[1].ftp) - (a[1].ssh + a[1].telnet + a[1].ftp))
                .slice(0, 5);

            usernamesChart.data.labels = topUsernames.map(([username]) => username);
            usernamesChart.data.datasets[0].data = topUsernames.map(([, counts]) => counts.ssh);
            usernamesChart.data.datasets[1].data = topUsernames.map(([, counts]) => counts.telnet);
            usernamesChart.data.datasets[2].data = topUsernames.map(([, counts]) => counts.ftp);
            usernamesChart.update();
        }

        // Add pagination event listeners
        document.getElementById('prevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                updateUI();
            }
        });

        document.getElementById('nextPage').addEventListener('click', () => {
            const filteredAttempts = filterAttempts(attempts);
            const totalPages = Math.ceil(filteredAttempts.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                updateUI();
            }
        });

        // Modify existing event listeners to reset pagination
        searchInput.addEventListener('input', () => {
            currentPage = 1;
            updateUI();
        });
        
        filterSelect.addEventListener('change', () => {
            currentPage = 1;
            updateUI();
        });

        protocolSelect.addEventListener('change', () => {
            currentPage = 1;
            updateUI();
        });

        // Initialize chart configurations with responsive design
        const attemptsChart = new Chart(
            document.getElementById('attemptsChart'),
            {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'SSH',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark') 
                                ? '#8b5cf6'  // Purple for dark mode
                                : '#6d28d9',  // Darker purple for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'Telnet',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark')
                                ? '#3b82f6'  // Blue for dark mode
                                : '#2563eb',  // Darker blue for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'FTP',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark')
                                ? '#10b981'  // Green for dark mode
                                : '#059669',  // Darker green for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            }
                        },
                        title: {
                            display: false
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            }
        );

        const usernamesChart = new Chart(
            document.getElementById('usernamesChart'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'SSH',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(139, 92, 246, 0.8)'   // Purple with opacity for dark mode
                                : 'rgba(109, 40, 217, 0.8)',  // Darker purple with opacity for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'Telnet',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(59, 130, 246, 0.8)'  // Blue with opacity for dark mode
                                : 'rgba(37, 99, 235, 0.8)',  // Darker blue with opacity for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'FTP',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(16, 185, 129, 0.8)'  // Green with opacity for dark mode
                                : 'rgba(5, 150, 105, 0.8)',  // Darker green with opacity for light mode
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            stacked: true,
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            }
                        }
                    }
                }
            }
        );

        // Initialize WebSocket connection for real-time updates
        connectWebSocket();

        // Expo
        document.getElementById('exportIPs').addEventListener('click', () => {
            // Open in new tab
            window.open('/api/export/ips', '_blank');
        });
    </script>
</body>
</html> 