<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honeypotter</title>
    <link rel="icon" type="image/svg+xml" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="%23000000"><path d="M61.3 27.991c-.463-2.989-2.297-12.947-6.459-15.575c-.068-.042-.127-.081-.177-.114a9.687 9.687 0 0 0-.111-2.649C53.954 6.161 49.429 2 31.272 2C13.075 2 8.542 6.161 7.944 9.651a10.029 10.029 0 0 0-.127 2.641c-.064.05-.146.111-.251.186c-2.087 1.488-5.042 7.881-5.27 11.4c-.1 1.546.269 2.719 1.095 3.486c.103.096.216.17.326.253C2.861 29.897 2 32.961 2 36.075c0 4.122.866 7.474 4.245 11.08c3.377 3.606 3.028 3.36 3.377 5.114C9.974 54.023 12.745 62 31.247 62h.002c18.502 0 21.589-7.948 21.623-9.73c.027-1.354.435-2.12 1.408-3.204c.711.55 1.461.869 2.297.869c.678 0 1.672-.223 2.566-1.282c3.336-3.958 3.301-13.269 2.157-20.662M31.242 56.044c-13.896 0-21.681-5.621-21.681-6.133c0-.511 7.785 4.279 21.681 4.279c13.892 0 21.677-4.79 21.677-4.279c0 .512-7.785 6.133-21.677 6.133m26.421-8.64c-.347.412-.709.595-1.086.595c-3.079 0-7.105-12.257-11.436-12.257c-6.261 0-4.728-12.934-11.883-12.934c-1.926 0-10.222 6.403-12.778 6.403c-2.557 0-2.94-6.403-6.006-6.403c-3.717 0-6.51 3.61-8.609 3.61c-.412 0-.798-.139-1.159-.473c-1.891-1.755 2.148-10.584 3.983-11.891c1.835-1.311.667-1.182 1.162-4.075c.496-2.895 5.654-6.043 21.421-6.043c15.762 0 20.898 3.271 21.374 6.043c.495 2.894-.745 2.871 1.162 4.075c5.285 3.336 8.863 27.412 3.855 33.35" />
                        <path d="M31.249 16.766c-11.895 0-21.001-3.797-21.001-3.285c0 .513 9.106 4.892 21.001 4.892c11.893 0 21.001-4.379 21.001-4.892c0-.512-9.108 3.285-21.001 3.285" />
                        <path d="M16.614 9.664c2.648.987 8.198 1.667 14.635 1.667c6.438 0 11.987-.68 14.635-1.667c1.055-.395 1.662-.833 1.662-1.3c0-1.639-7.296-2.968-16.297-2.968c-9 0-16.296 1.329-16.296 2.968c0 .467.607.906 1.661 1.3" />
                    </svg>'>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
        #map {
            height: 400px;
            width: 100%;
            border-radius: 0.5rem;
            z-index: 1;
            position: relative;
        }
        .location-popup {
            font-size: 14px;
            line-height: 1.4;
        }

        /* Loading overlay styles */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
            visibility: visible;
            backdrop-filter: blur(4px);
        }

        #loadingOverlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #e5e7eb;
            border-top: 5px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        .loading-text {
            color: #1f2937;
            font-size: 1.2rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.1);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Dark mode adjustments for loading overlay */
        .dark #loadingOverlay {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .dark .loading-spinner {
            border-color: #374151;
            border-top-color: #60a5fa;
        }

        .dark .loading-text {
            color: #f3f4f6;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Core dark mode theme configuration */
        .dark body { background-color: rgb(17, 24, 39); }
        .dark nav { background-color: rgb(31, 41, 55); }
        .dark h1, .dark h2 { color: rgb(255, 255, 255); }
        .dark .bg-white { background-color: rgb(31, 41, 55); }
        .dark .text-gray-800 { color: rgb(243, 244, 246); }
        .dark .text-gray-600 { color: rgb(209, 213, 219); }
        .dark .bg-gray-50 { background-color: rgb(55, 65, 81); }
        .dark .hover\:bg-gray-100:hover { background-color: rgb(75, 85, 99); }
        .dark .border-gray-200 { border-color: rgb(75, 85, 99); }

        /* Smooth transitions for theme switching */
        * {
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        /* Dark mode color scheme overrides */
        .dark body { 
            background-color: #1a1a1a;
        }
        .dark .bg-white { 
            background-color: #2d2d2d !important;
        }
        .dark .bg-gray-100 { 
            background-color: #1a1a1a !important;
        }
        .dark .bg-gray-50 { 
            background-color: #3d3d3d !important;
        }
        .dark .text-gray-800 { 
            color: #f3f4f6 !important;
        }
        .dark .text-gray-600 { 
            color: #d1d5db !important;
        }
        .dark .border-gray-200 { 
            border-color: #4b5563 !important;
        }
        .dark .shadow { 
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3);
        }
        .dark .hover\:bg-gray-100:hover { 
            background-color: #4b5563 !important;
        }

        /* Dark mode text and interactive elements */
        .dark * { color: #f3f4f6; }
        .dark svg { color: #f3f4f6; }
        .dark a { color: #60a5fa; }
        .dark a:hover { color: #93c5fd; }
        .dark input::placeholder { color: #9ca3af; }
        
        /* Semantic color preservation */
        .dark .text-red-600 { color: #dc2626 !important; }
        .dark .text-green-600 { color: #059669 !important; }
        
        /* Form elements dark mode styling */
        .dark input, 
        .dark select { 
            background-color: #3d3d3d !important;
            color: #f3f4f6 !important;
            border-color: #4b5563 !important;
        }
        .dark button:not(#darkModeToggle) {
            background-color: #3d3d3d !important;
            color: #f3f4f6 !important;
        }
        .dark button:not(#darkModeToggle):hover {
            background-color: #4b5563 !important;
        }
        .dark #attempts > div {
            background-color: #3d3d3d !important;
        }
        .dark #attempts > div:hover {
            background-color: #4b5563 !important;
        }

        /* Chart component dark mode adjustments */
        .dark .chart-container {
            color: #f3f4f6;
        }

        /* Leaflet map controls dark mode preservation */
        .dark .leaflet-control-zoom a,
        .dark .leaflet-control-zoom-in,
        .dark .leaflet-control-zoom-out,
        .dark .leaflet-control * {
            color: #000 !important;
            background-color: #fff !important;
        }
        
        .dark .leaflet-control-zoom a:hover,
        .dark .leaflet-control-zoom-in:hover,
        .dark .leaflet-control-zoom-out:hover {
            background-color: #f4f4f4 !important;
        }
        
        .dark .leaflet-control-attribution {
            color: #000 !important;
            background-color: rgba(255, 255, 255, 0.8) !important;
        }
        
        .dark .leaflet-control-attribution a {
            color: #0078A8 !important;
        }

        /* Custom attribution styling */
        .leaflet-control-attribution {
            font-size: 8px !important;
            padding: 2px 4px !important;
            background-color: rgba(255, 255, 255, 0.7) !important;
        }

        .leaflet-control-attribution a {
            font-size: 8px !important;
        }

        /* Dark mode map tile styling */
        .dark-tiles {
            filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
        }

        /* Responsive layout adjustments */
        @media (max-width: 768px) {
            .chart-container {
                height: 250px;
            }
            
            #map {
                height: 300px;
            }
            
            .container {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }
            
            nav .container {
                max-width: 100%;
            }

            /* Chart text size optimization for mobile */
            .chart-js-render-monitor {
                font-size: 12px;
            }

            /* Mobile-specific optimizations */
            * {
                transition: background-color 0.15s ease-out, color 0.15s ease-out;
            }
        }

        /* Small device breakpoint utilities */
        @media (min-width: 640px) {
            .sm\:inline {
                display: inline;
            }
        }

        /* Connection status indicator dark mode preservation */
        .dark #connectionStatusContainer,
        .dark #connectionStatus,
        .dark #connectionStatusIcon {
            color: inherit !important;
            background-color: inherit !important;
        }

        .dark #connectionStatusContainer.bg-red-100 {
            background-color: rgb(254, 226, 226) !important;
        }

        .dark #connectionStatusContainer.bg-green-100 {
            background-color: rgb(220, 252, 231) !important;
        }

        .dark #connectionStatus.text-red-600,
        .dark #connectionStatusIcon.text-red-600 {
            color: rgb(220, 38, 38) !important;
        }

        .dark #connectionStatus.text-green-600,
        .dark #connectionStatusIcon.text-green-600 {
            color: rgb(5, 150, 105) !important;
        }

        /* Map popup dark mode styling */
        .dark .leaflet-popup-content-wrapper {
            background-color: #374151;
            color: #f3f4f6;
        }

        .dark .leaflet-popup-tip {
            background-color: #374151;
        }

        .dark .location-popup strong {
            color: #60a5fa;
        }

        .dark .leaflet-container a.leaflet-popup-close-button {
            color: #f3f4f6;
        }

        .dark .leaflet-container a.leaflet-popup-close-button:hover {
            color: #60a5fa;
        }

        /* Connection status indicator styles */
        #connectionStatusIndicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        #connectionStatusIndicator.connected {
            background-color: rgb(22, 163, 74);
        }

        #connectionStatusIndicator.reconnecting {
            background-color: rgb(234, 179, 8);
        }

        #connectionStatusIndicator.disconnected {
            background-color: rgb(220, 38, 38);
        }

        #connectionStatusIndicator svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        .dark #connectionStatusIndicator.connected {
            background-color: rgb(34, 197, 94);
        }

        .dark #connectionStatusIndicator.reconnecting {
            background-color: rgb(250, 204, 21);
        }

        .dark #connectionStatusIndicator.disconnected {
            background-color: rgb(239, 68, 68);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        /* Mobile Menu Styles */
        #mobileMenu {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            width: 16rem;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        #mobileMenu:not(.hidden) {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            pointer-events: auto;
        }

        .dark #mobileMenu {
            background-color: #1f2937;
        }

        /* Menu overlay styles */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 900;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(3px);
        }

        .menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* FAQ Modal Styles */
        #faqModal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
        }

        #faqModal:not(.hidden) {
            opacity: 1;
            visibility: visible;
        }

        #faqModal .bg-white {
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #faqModal:not(.hidden) .bg-white {
            transform: scale(1);
            opacity: 1;
        }

        /* Mobile menu button hover states */
        #mobileMenu button {
            width: 100%;
            text-align: left;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.2s ease;
            border-radius: 0.375rem;
        }

        #mobileMenu button:hover {
            background-color: #f3f4f6;
            transform: translateX(4px);
            transition: all 0.2s ease;
        }

        .dark #mobileMenu button:hover {
            background-color: #374151;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #mobileMenu {
                width: calc(100vw - 2rem);
                right: 1rem;
                top: calc(100% + 0.75rem);
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <nav class="bg-white dark:bg-gray-800 shadow-lg mb-8">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <svg class="w-6 h-6 mr-2" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" stroke="none" fill="currentColor">
                        <path d="M61.3 27.991c-.463-2.989-2.297-12.947-6.459-15.575c-.068-.042-.127-.081-.177-.114a9.687 9.687 0 0 0-.111-2.649C53.954 6.161 49.429 2 31.272 2C13.075 2 8.542 6.161 7.944 9.651a10.029 10.029 0 0 0-.127 2.641c-.064.05-.146.111-.251.186c-2.087 1.488-5.042 7.881-5.27 11.4c-.1 1.546.269 2.719 1.095 3.486c.103.096.216.17.326.253C2.861 29.897 2 32.961 2 36.075c0 4.122.866 7.474 4.245 11.08c3.377 3.606 3.028 3.36 3.377 5.114C9.974 54.023 12.745 62 31.247 62h.002c18.502 0 21.589-7.948 21.623-9.73c.027-1.354.435-2.12 1.408-3.204c.711.55 1.461.869 2.297.869c.678 0 1.672-.223 2.566-1.282c3.336-3.958 3.301-13.269 2.157-20.662M31.242 56.044c-13.896 0-21.681-5.621-21.681-6.133c0-.511 7.785 4.279 21.681 4.279c13.892 0 21.677-4.79 21.677-4.279c0 .512-7.785 6.133-21.677 6.133m26.421-8.64c-.347.412-.709.595-1.086.595c-3.079 0-7.105-12.257-11.436-12.257c-6.261 0-4.728-12.934-11.883-12.934c-1.926 0-10.222 6.403-12.778 6.403c-2.557 0-2.94-6.403-6.006-6.403c-3.717 0-6.51 3.61-8.609 3.61c-.412 0-.798-.139-1.159-.473c-1.891-1.755 2.148-10.584 3.983-11.891c1.835-1.311.667-1.182 1.162-4.075c.496-2.895 5.654-6.043 21.421-6.043c15.762 0 20.898 3.271 21.374 6.043c.495 2.894-.745 2.871 1.162 4.075c5.285 3.336 8.863 27.412 3.855 33.35" />
                        <path d="M31.249 16.766c-11.895 0-21.001-3.797-21.001-3.285c0 .513 9.106 4.892 21.001 4.892c11.893 0 21.001-4.379 21.001-4.892c0-.512-9.108 3.285-21.001 3.285" />
                        <path d="M16.614 9.664c2.648.987 8.198 1.667 14.635 1.667c6.438 0 11.987-.68 14.635-1.667c1.055-.395 1.662-.833 1.662-1.3c0-1.639-7.296-2.968-16.297-2.968c-9 0-16.296 1.329-16.296 2.968c0 .467.607.906 1.661 1.3" />
                    </svg>
                    <h1 class="text-xl font-semibold text-gray-800">Honeypotter</h1>
                </div>
                <div class="flex items-center gap-4">
                    <div class="p-2 w-[88px] rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3V7M12 17V21M3 12H7M17 12H21M12 12H12.01M19 12C19 15.866 15.866 19 12 19C8.13401 19 5 15.866 5 12C5 8.13401 8.13401 5 12 5C15.866 5 19 8.13401 19 12Z"/>
                        </svg>
                        <span id="totalAttempts" class="font-semibold">0</span>
                    </div>
                    <!-- Hamburger Menu Button -->
                    <div class="relative">
                        <button id="hamburgerBtn" class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                            </svg>
                        </button>
                        <!-- Mobile Menu -->
                        <div id="mobileMenu" class="hidden absolute top-full right-0 w-64 bg-white dark:bg-gray-800 shadow-lg rounded-lg z-50">
                            <div class="p-4 space-y-4">
                                <button id="exportIPsMenu" class="w-full p-2 flex items-center gap-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                    <span>Export IPs</span>
                                </button>
                                <button id="faqButton" class="w-full p-2 flex items-center gap-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                    <span>FAQ</span>
                                </button>
                                <button id="darkModeToggleMenu" class="w-full p-2 flex items-center gap-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                                    <svg id="darkIconMenu" class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                                    </svg>
                                    <svg id="lightIconMenu" class="w-5 h-5 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                                    </svg>
                                    <span id="themeText">Light Mode</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 pb-8">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
            <h2 class="text-xl font-semibold mb-4">Attack Origins</h2>
            <div id="map"></div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Protocol Activity</h2>
                <div class="chart-container">
                    <canvas id="attemptsChart"></canvas>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Top Usernames</h2>
                <div class="chart-container">
                    <canvas id="usernamesChart"></canvas>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Source IPs</h2>
                <div class="chart-container">
                    <canvas id="ipsChart"></canvas>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4">Attack Origins</h2>
                <div class="chart-container">
                    <canvas id="countriesChart"></canvas>
                </div>
            </div>
        </div>

        <div class="bg-white dark:bg-gray-800 rounded-lg shadow">
            <div class="p-4 border-b border-gray-200">
                <h2 class="text-xl font-semibold">Recent Login Attempts</h2>
            </div>
            <div class="p-4">
                <div class="flex flex-col sm:flex-row items-center gap-4 mb-4">
                    <div class="w-full sm:w-2/3">
                        <input type="text" id="searchInput" placeholder="Search..." 
                               class="w-full px-4 py-2 border rounded-lg">
                    </div>
                    <div class="w-full sm:w-1/3 flex flex-col sm:flex-row gap-4">
                        <div class="w-full sm:w-1/2">
                            <select id="filterSelect" class="w-full px-4 py-2 border rounded-lg">
                                <option value="all">All Time</option>
                                <option value="lastHour">Last Hour</option>
                                <option value="today">Today</option>
                                <option value="thisWeek">This Week</option>
                            </select>
                        </div>
                        <div class="w-full sm:w-1/2">
                            <select id="protocolSelect" class="w-full px-4 py-2 border rounded-lg">
                                <option value="all">All Protocols</option>
                                <option value="ssh">SSH Only</option>
                                <option value="telnet">Telnet Only</option>
                                <option value="ftp">FTP Only</option>
                                <option value="smtp">SMTP Only</option>
                                <option value="rdp">RDP Only</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div id="attempts" class="space-y-4"></div>
                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <div class="text-sm text-gray-600 order-2 sm:order-1">
                        Showing <span id="startRange">0</span>-<span id="endRange">0</span> of <span id="totalItems">0</span> attempts
                    </div>
                    <div class="flex space-x-2 order-1 sm:order-2">
                        <button id="prevPage" class="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Previous
                        </button>
                        <button id="nextPage" class="px-3 py-1 bg-gray-100 rounded hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Next
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="bg-white dark:bg-gray-800 shadow-lg mt-8 py-4">
        <div class="container mx-auto px-4 text-center text-gray-600">
            made with ❤️ by <a href="https://github.com/thejordanprice" class="text-blue-600 hover:text-blue-800 transition-colors" target="_blank">thejordanprice</a>
        </div>
    </footer>

    <!-- Connection status indicator -->
    <div id="connectionStatusIndicator" class="connected">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
        </svg>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="flex items-center bg-white dark:bg-gray-800 rounded-lg p-6 shadow-xl">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading data...</div>
        </div>
    </div>

    <!-- FAQ Modal -->
    <div id="faqModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white dark:bg-gray-800 w-11/12 max-w-2xl rounded-lg shadow-xl">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold">Frequently Asked Questions</h2>
                    <button id="closeFaqModal" class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                <div class="space-y-6">
                    <div>
                        <h3 class="text-lg font-semibold mb-2">What is Honeypotter?</h3>
                        <p class="text-gray-600 dark:text-gray-300">Honeypotter is a honeypot monitoring system that tracks and visualizes attempted unauthorized access to various network services (SSH, Telnet, FTP, SMTP, RDP). It helps security researchers and system administrators understand attack patterns and origins.</p>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-2">How does it work?</h3>
                        <p class="text-gray-600 dark:text-gray-300">The system sets up decoy services that log connection attempts, usernames, passwords, and IP addresses. This data is then analyzed and displayed in real-time through various charts and visualizations.</p>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-2">What information is collected?</h3>
                        <p class="text-gray-600 dark:text-gray-300">For each connection attempt, we log:
                            <ul class="list-disc ml-6 mt-2">
                                <li>IP address and geolocation data</li>
                                <li>Attempted username and password</li>
                                <li>Protocol used (SSH, Telnet, etc.)</li>
                                <li>Timestamp of the attempt</li>
                            </ul>
                        </p>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-2">Is this legal?</h3>
                        <p class="text-gray-600 dark:text-gray-300">Yes. Honeypots are legal security tools used for research and defense. We don't engage with attackers or collect any data beyond what they voluntarily provide in their connection attempts.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize theme based on user preference or system settings
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
            const lightIconMenu = document.getElementById('lightIconMenu');
            const darkIconMenu = document.getElementById('darkIconMenu');
            const themeText = document.getElementById('themeText');
            if (lightIconMenu && darkIconMenu) {
                lightIconMenu.classList.remove('hidden');
                darkIconMenu.classList.add('hidden');
            }
            if (themeText) {
                themeText.textContent = 'Light Mode';
            }
        } else {
            const themeText = document.getElementById('themeText');
            if (themeText) {
                themeText.textContent = 'Dark Mode';
            }
        }

        // Wait for DOM to be fully loaded before adding event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Hamburger Menu
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const mobileMenu = document.getElementById('mobileMenu');
            const exportIPsMenu = document.getElementById('exportIPsMenu');
            const darkModeToggleMenu = document.getElementById('darkModeToggleMenu');
            const faqButton = document.getElementById('faqButton');
            const faqModal = document.getElementById('faqModal');
            const closeFaqModal = document.getElementById('closeFaqModal');

            if (hamburgerBtn && mobileMenu) {
                hamburgerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isHidden = mobileMenu.classList.contains('hidden');
                    
                    // Toggle menu visibility
                    mobileMenu.classList.toggle('hidden');
                    
                    // Handle overlay
                    if (!mobileMenu.classList.contains('hidden')) {
                        // Add overlay if menu is visible
                        const overlay = document.createElement('div');
                        overlay.className = 'menu-overlay';
                        document.body.appendChild(overlay);
                        
                        // Ensure overlay is visible after being added to DOM
                        requestAnimationFrame(() => {
                            overlay.classList.add('active');
                        });
                    } else {
                        // Remove overlay if menu is hidden
                        const overlay = document.querySelector('.menu-overlay');
                        if (overlay) {
                            overlay.classList.remove('active');
                            setTimeout(() => overlay.remove(), 300);
                        }
                    }
                });
            }

            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (mobileMenu && !mobileMenu.contains(e.target) && !hamburgerBtn.contains(e.target)) {
                    mobileMenu.classList.add('hidden');
                    const overlay = document.querySelector('.menu-overlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                        setTimeout(() => overlay.remove(), 300);
                    }
                }
            });

            // Prevent menu from closing when clicking inside
            if (mobileMenu) {
                mobileMenu.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            // Menu item click handlers
            if (exportIPsMenu) {
                exportIPsMenu.addEventListener('click', () => {
                    mobileMenu.classList.add('hidden');
                    const overlay = document.querySelector('.menu-overlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                        setTimeout(() => overlay.remove(), 300);
                    }
                    window.open('/api/export/ips', '_blank');
                });
            }

            if (darkModeToggleMenu) {
                darkModeToggleMenu.addEventListener('click', () => {
                    const isDark = document.documentElement.classList.toggle('dark');
                    const lightIconMenu = document.getElementById('lightIconMenu');
                    const darkIconMenu = document.getElementById('darkIconMenu');
                    const themeText = document.getElementById('themeText');
                    
                    if (lightIconMenu && darkIconMenu) {
                        lightIconMenu.classList.toggle('hidden');
                        darkIconMenu.classList.toggle('hidden');
                    }
                    
                    if (themeText) {
                        themeText.textContent = isDark ? 'Light Mode' : 'Dark Mode';
                    }
                    
                    localStorage.theme = isDark ? 'dark' : 'light';
                    mobileMenu.classList.add('hidden');
                    
                    const overlay = document.querySelector('.menu-overlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                        setTimeout(() => overlay.remove(), 300);
                    }

                    // Update map theme
                    setMapTheme(isDark);

                    // Update chart colors based on theme
                    const chartTextColor = isDark ? '#f3f4f6' : '#1f2937';
                    const gridColor = isDark ? '#374151' : '#e5e7eb';
                    
                    // Update all charts if they exist
                    if (typeof attemptsChart !== 'undefined') {
                        // Update attempts chart colors
                        attemptsChart.options.scales.x.ticks.color = chartTextColor;
                        attemptsChart.options.scales.y.ticks.color = chartTextColor;
                        attemptsChart.options.scales.x.grid.color = gridColor;
                        attemptsChart.options.scales.y.grid.color = gridColor;
                        attemptsChart.options.plugins.legend.labels.color = chartTextColor;
                        attemptsChart.data.datasets[0].borderColor = isDark ? '#8b5cf6' : '#6d28d9';
                        attemptsChart.data.datasets[1].borderColor = isDark ? '#3b82f6' : '#2563eb';
                        attemptsChart.data.datasets[2].borderColor = isDark ? '#10b981' : '#059669';
                        attemptsChart.data.datasets[3].borderColor = isDark ? '#f59e0b' : '#d97706';
                        attemptsChart.data.datasets[4].borderColor = isDark ? '#ec4899' : '#db2777';
                        attemptsChart.update();
                    }

                    if (typeof usernamesChart !== 'undefined') {
                        // Update usernames chart colors
                        usernamesChart.options.scales.x.ticks.color = chartTextColor;
                        usernamesChart.options.scales.y.ticks.color = chartTextColor;
                        usernamesChart.options.scales.x.grid.color = gridColor;
                        usernamesChart.options.scales.y.grid.color = gridColor;
                        usernamesChart.options.plugins.legend.labels.color = chartTextColor;
                        usernamesChart.data.datasets[0].backgroundColor = isDark ? 'rgba(139, 92, 246, 0.8)' : 'rgba(109, 40, 217, 0.8)';
                        usernamesChart.data.datasets[1].backgroundColor = isDark ? 'rgba(59, 130, 246, 0.8)' : 'rgba(37, 99, 235, 0.8)';
                        usernamesChart.data.datasets[2].backgroundColor = isDark ? 'rgba(16, 185, 129, 0.8)' : 'rgba(5, 150, 105, 0.8)';
                        usernamesChart.data.datasets[3].backgroundColor = isDark ? 'rgba(245, 158, 11, 0.8)' : 'rgba(217, 119, 6, 0.8)';
                        usernamesChart.data.datasets[4].backgroundColor = isDark ? 'rgba(236, 72, 153, 0.8)' : 'rgba(219, 39, 119, 0.8)';
                        usernamesChart.update();
                    }

                    if (typeof ipsChart !== 'undefined') {
                        // Update IPs chart colors
                        ipsChart.options.scales.x.ticks.color = chartTextColor;
                        ipsChart.options.scales.y.ticks.color = chartTextColor;
                        ipsChart.options.scales.x.grid.color = gridColor;
                        ipsChart.options.scales.y.grid.color = gridColor;
                        ipsChart.data.datasets[0].backgroundColor = isDark ? 'rgba(139, 92, 246, 0.8)' : 'rgba(109, 40, 217, 0.8)';
                        ipsChart.update();
                    }

                    if (typeof countriesChart !== 'undefined') {
                        // Update countries chart colors
                        countriesChart.options.scales.x.ticks.color = chartTextColor;
                        countriesChart.options.scales.y.ticks.color = chartTextColor;
                        countriesChart.options.scales.x.grid.color = gridColor;
                        countriesChart.options.scales.y.grid.color = gridColor;
                        countriesChart.data.datasets[0].backgroundColor = isDark ? 'rgba(59, 130, 246, 0.8)' : 'rgba(37, 99, 235, 0.8)';
                        countriesChart.update();
                    }
                });
            }

            // FAQ Modal handlers
            if (faqButton && faqModal) {
                faqButton.addEventListener('click', () => {
                    mobileMenu.classList.add('hidden');
                    const overlay = document.querySelector('.menu-overlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                        setTimeout(() => overlay.remove(), 300);
                    }
                    faqModal.classList.remove('hidden');
                });
            }

            if (closeFaqModal && faqModal) {
                closeFaqModal.addEventListener('click', () => {
                    faqModal.classList.add('hidden');
                });

                // Close FAQ modal when clicking outside
                faqModal.addEventListener('click', (e) => {
                    if (e.target === faqModal) {
                        faqModal.classList.add('hidden');
                    }
                });
            }

            // Close modals on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (mobileMenu && !mobileMenu.classList.contains('hidden')) {
                        mobileMenu.classList.add('hidden');
                        const overlay = document.querySelector('.menu-overlay');
                        if (overlay) {
                            overlay.classList.remove('active');
                            setTimeout(() => overlay.remove(), 300);
                        }
                    }
                    
                    if (faqModal && !faqModal.classList.contains('hidden')) {
                        faqModal.classList.add('hidden');
                    }
                }
            });
        });

        // Initialize map with light/dark theme support
        const map = L.map('map').setView([20, 0], 2);
        let currentTileLayer;

        // Add this new function before the tileLayer definitions
        function centerMapOnMostActiveRegion(attempts) {
            if (!attempts || attempts.length === 0) return;

            // Create a grid to count attacks in different regions
            const grid = {};
            const validAttempts = attempts.filter(a => a.latitude && a.longitude);
            
            if (validAttempts.length === 0) return;

            // Round coordinates to create grid cells (1 degree resolution)
            validAttempts.forEach(attempt => {
                const lat = Math.round(attempt.latitude);
                const lng = Math.round(attempt.longitude);
                const key = `${lat},${lng}`;
                grid[key] = (grid[key] || 0) + 1;
            });

            // Find the cell with most attacks
            let maxCount = 0;
            let hotspotCenter = null;
            
            for (const [coords, count] of Object.entries(grid)) {
                if (count > maxCount) {
                    maxCount = count;
                    const [lat, lng] = coords.split(',').map(Number);
                    hotspotCenter = [lat, lng];
                }
            }

            // If we found a hotspot, center the map there with appropriate zoom
            if (hotspotCenter) {
                const zoom = window.innerWidth <= 768 ? 2 : 3; // Reduced zoom levels by 1
                map.setView(hotspotCenter, zoom, { animate: true });
            }
        }

        const lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        });

        const darkTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            className: 'dark-tiles'
        });

        // Function to set the appropriate tile layer
        function setMapTheme(isDark) {
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }
            currentTileLayer = isDark ? darkTileLayer : lightTileLayer;
            currentTileLayer.addTo(map);
        }

        // Initial theme setup
        setMapTheme(document.documentElement.classList.contains('dark'));

        // Store map markers to prevent duplicate markers at same location
        const markers = new Map();

        function updateMap(attempt) {
            if (attempt.latitude && attempt.longitude) {
                const key = `${attempt.latitude},${attempt.longitude}`;
                let marker = markers.get(key);
                
                if (!marker) {
                    marker = {
                        leaflet: L.marker([attempt.latitude, attempt.longitude]),
                        attempts: new Set()
                    };
                    markers.set(key, marker);
                    marker.leaflet.addTo(map);
                }

                // Create a unique key for each attempt using timestamp and IP
                const attemptKey = `${attempt.timestamp}_${attempt.client_ip}_${attempt.username}_${attempt.protocol}`;
                const previousSize = marker.attempts.size;
                marker.attempts.add(attemptKey);
                
                // Log if this was actually a new attempt
                if (marker.attempts.size > previousSize) {
                    console.log(`New unique attempt at ${key}: ${attemptKey}`);
                    console.log(`Location now has ${marker.attempts.size} unique attempts`);
                }
                
                const location = [
                    attempt.city,
                    attempt.region,
                    attempt.country
                ].filter(Boolean).join(', ');

                const popupContent = `
                    <div class="location-popup">
                        <strong>${location}</strong><br>
                        Total Attempts: ${marker.attempts.size}<br>
                        Latest: ${attempt.username}@${attempt.client_ip}
                    </div>
                `;
                
                marker.leaflet.bindPopup(popupContent);
            }
        }

        const attemptsDiv = document.getElementById("attempts");
        const searchInput = document.getElementById("searchInput");
        const filterSelect = document.getElementById("filterSelect");
        const protocolSelect = document.getElementById("protocolSelect");
        const connectionStatus = document.getElementById("connectionStatus");
        let attempts = [];
        let socket = null;

        function updateConnectionStatus(status, isError = false) {
            const indicator = document.getElementById('connectionStatusIndicator');
            const svg = indicator.querySelector('svg');
            
            if (status.includes('Connected')) {
                indicator.className = 'connected';
                svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>';
                svg.classList.remove('animate-spin');
            } else if (status.includes('Connecting')) {
                indicator.className = 'reconnecting';
                svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>';
                svg.classList.add('animate-spin');
            } else {
                indicator.className = 'disconnected';
                svg.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>';
                svg.classList.remove('animate-spin');
            }
        }

        // Function to show/hide loading overlay with animation
        function toggleLoadingOverlay(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.remove('hidden');
                document.body.style.overflow = 'hidden'; // Prevent scrolling while loading
                
                // Ensure the overlay is visible before adding animation classes
                requestAnimationFrame(() => {
                    overlay.style.opacity = '1';
                    overlay.style.visibility = 'visible';
                });
            } else {
                overlay.style.opacity = '0';
                overlay.style.visibility = 'hidden';
                document.body.style.overflow = ''; // Restore scrolling
                
                // Add hidden class after animation completes
                setTimeout(() => {
                    overlay.classList.add('hidden');
                }, 300); // Match the transition duration
            }
        }

        // Show loading overlay initially
        toggleLoadingOverlay(true);

        // Modify the WebSocket connection function to handle loading state
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            updateConnectionStatus('Connecting to WebSocket...');
            
            socket = new WebSocket(wsUrl);

            socket.onopen = function() {
                updateConnectionStatus('Connected to WebSocket');
                fetch('/api/attempts')
                    .then(response => response.json())
                    .then(data => {
                        attempts = data;
                        
                        // Get current filter state
                        const currentFilters = {
                            search: searchInput.value.toLowerCase().trim(),
                            filter: filterSelect.value,
                            protocol: protocolSelect.value
                        };
                        
                        // Apply filters to the fetched data
                        const filteredAttempts = filterAttempts(attempts);
                        
                        // Update UI with filtered data
                        updateUI();
                        
                        // Hide loading overlay after everything is loaded and add a slight delay
                        setTimeout(() => toggleLoadingOverlay(false), 500);
                    })
                    .catch(error => {
                        console.error('Error fetching data:', error);
                        // Hide loading overlay even if there's an error
                        toggleLoadingOverlay(false);
                    });
            };

            socket.onerror = function(error) {
                updateConnectionStatus('WebSocket error: ' + error.message, true);
                console.error('WebSocket error:', error);
                toggleLoadingOverlay(false);
            };

            socket.onclose = function() {
                updateConnectionStatus('WebSocket connection closed. Reconnecting...', true);
                toggleLoadingOverlay(false);
                setTimeout(connectWebSocket, 5000);
            };

        }

        function formatDateToLocalTime(isoString) {
            // Ensure proper UTC timestamp parsing for consistent timezone handling
            const date = new Date(isoString + 'Z');
            
            return date.toLocaleString(undefined, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true,
                timeZoneName: 'short'
            });
        }

        function createAttemptElement(attempt) {
            const location = [
                attempt.city,
                attempt.region,
                attempt.country
            ].filter(Boolean).join(', ');

            return `
                <div class="bg-gray-50 rounded-lg p-4 hover:bg-gray-100 transition-colors">
                    <div class="flex flex-col sm:flex-row justify-between gap-2">
                        <span class="font-semibold break-all">
                            ${attempt.username}@${attempt.client_ip}
                            <span class="inline-block px-2 py-1 text-xs rounded-full ml-2">
                                ${attempt.protocol.toUpperCase()}
                            </span>
                        </span>
                        <span class="text-gray-500 text-sm">${formatDateToLocalTime(attempt.timestamp)}</span>
                    </div>
                    <div class="text-gray-600 mt-2">
                        <div class="break-all">Password: ${attempt.password}</div>
                        ${location ? `<div class="text-sm mt-1">Location: ${location}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function filterAttempts(attempts) {
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filterValue = filterSelect.value;
            const protocolValue = protocolSelect.value;
            const now = new Date();

            return attempts.filter(attempt => {
                const matchesSearch = searchTerm === '' || 
                    attempt.username.toLowerCase().includes(searchTerm) ||
                    attempt.client_ip.includes(searchTerm) ||
                    attempt.password.toLowerCase().includes(searchTerm);

                const matchesProtocol = protocolValue === 'all' || attempt.protocol === protocolValue;

                // Create date object from UTC timestamp
                const timestamp = new Date(attempt.timestamp + 'Z');
                let matchesFilter = true;

                switch (filterValue) {
                    case 'lastHour':
                        matchesFilter = (now - timestamp) <= (60 * 60 * 1000);
                        break;
                    case 'today':
                        // Compare using local dates
                        const attemptDate = new Date(timestamp.toLocaleDateString());
                        const todayDate = new Date(now.toLocaleDateString());
                        matchesFilter = attemptDate.getTime() === todayDate.getTime();
                        break;
                    case 'thisWeek':
                        const weekAgo = new Date(now);
                        weekAgo.setDate(now.getDate() - 7);
                        matchesFilter = timestamp >= weekAgo;
                        break;
                    case 'all':
                    default:
                        matchesFilter = true;
                        break;
                }

                return matchesSearch && matchesFilter && matchesProtocol;
            });
        }

        let currentPage = 1;
        const itemsPerPage = 10;

        function updateUI() {
            const filteredAttempts = filterAttempts(attempts);
            const totalItems = filteredAttempts.length;
            
            // Update total attempts in navbar
            document.getElementById('totalAttempts').textContent = attempts.length;
            
            // Calculate pagination
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, totalItems);
            
            // Update pagination display
            document.getElementById('startRange').textContent = totalItems ? startIndex + 1 : 0;
            document.getElementById('endRange').textContent = endIndex;
            document.getElementById('totalItems').textContent = totalItems;
            
            // Update pagination buttons
            document.getElementById('prevPage').disabled = currentPage === 1;
            document.getElementById('nextPage').disabled = endIndex >= totalItems;
            
            // Display paginated results
            const paginatedAttempts = filteredAttempts.slice(startIndex, endIndex);
            attemptsDiv.innerHTML = paginatedAttempts
                .map(attempt => createAttemptElement(attempt))
                .join('');

            // Update all visualizations with filtered data
            updateVisualizations(filteredAttempts);
        }

        // New function to update all visualizations with filtered data
        function updateVisualizations(filteredAttempts) {
            // Clear existing markers from the map
            markers.forEach(marker => {
                map.removeLayer(marker.leaflet);
            });
            markers.clear();

            // Update map with filtered attempts
            filteredAttempts.forEach(updateMap);
            centerMapOnMostActiveRegion(filteredAttempts);

            // Get current time and filter value
            const now = new Date();
            const filterValue = filterSelect.value;
            
            // Initialize arrays for protocol data
            let timeLabels = [];
            let sshData = [];
            let telnetData = [];
            let ftpData = [];
            let smtpData = [];
            let rdpData = [];

            // Function to format hour with AM/PM
            const formatHour = (hour) => {
                const h = hour % 12 || 12;
                const ampm = hour >= 12 ? 'PM' : 'AM';
                return `${h}${ampm}`;
            };

            // Function to format time with minutes
            const formatTimeWithMinutes = (hour, minutes) => {
                const h = hour % 12 || 12;
                const ampm = hour >= 12 ? 'PM' : 'AM';
                return `${h}:${minutes.toString().padStart(2, '0')}${ampm}`;
            };

            // Function to format date
            const formatDate = (date) => {
                return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
            };

            // Sort attempts by timestamp
            const sortedAttempts = [...filteredAttempts].sort((a, b) => 
                new Date(a.timestamp + 'Z') - new Date(b.timestamp + 'Z')
            );

            if (filterValue === 'lastHour') {
                // Show last hour in 5-minute intervals
                const intervals = 12; // 5-minute intervals
                timeLabels = Array.from({length: intervals}, (_, i) => {
                    const minutes = (now.getMinutes() - ((intervals - 1 - i) * 5) + 60) % 60;
                    return formatTimeWithMinutes(now.getHours(), minutes);
                });
                
                sshData = new Array(intervals).fill(0);
                telnetData = new Array(intervals).fill(0);
                ftpData = new Array(intervals).fill(0);
                smtpData = new Array(intervals).fill(0);
                rdpData = new Array(intervals).fill(0);

                sortedAttempts.forEach(attempt => {
                    const date = new Date(attempt.timestamp + 'Z');
                    const minutesAgo = Math.floor((now - date) / (1000 * 60));
                    if (minutesAgo <= 60) {
                        const intervalIndex = Math.floor((60 - minutesAgo) / 5);
                        if (intervalIndex >= 0 && intervalIndex < intervals) {
                            if (attempt.protocol === 'ssh') sshData[intervalIndex]++;
                            else if (attempt.protocol === 'telnet') telnetData[intervalIndex]++;
                            else if (attempt.protocol === 'ftp') ftpData[intervalIndex]++;
                            else if (attempt.protocol === 'smtp') smtpData[intervalIndex]++;
                            else if (attempt.protocol === 'rdp') rdpData[intervalIndex]++;
                        }
                    }
                });
            } else if (filterValue === 'today') {
                // Show today's data by hour
                const currentHour = now.getHours();
                timeLabels = Array.from({length: currentHour + 1}, (_, i) => formatHour(i));
                
                sshData = new Array(currentHour + 1).fill(0);
                telnetData = new Array(currentHour + 1).fill(0);
                ftpData = new Array(currentHour + 1).fill(0);
                smtpData = new Array(currentHour + 1).fill(0);
                rdpData = new Array(currentHour + 1).fill(0);

                sortedAttempts.forEach(attempt => {
                    const date = new Date(attempt.timestamp + 'Z');
                    if (date.toLocaleDateString() === now.toLocaleDateString()) {
                        const hour = date.getHours();
                        if (attempt.protocol === 'ssh') sshData[hour]++;
                        else if (attempt.protocol === 'telnet') telnetData[hour]++;
                        else if (attempt.protocol === 'ftp') ftpData[hour]++;
                        else if (attempt.protocol === 'smtp') smtpData[hour]++;
                        else if (attempt.protocol === 'rdp') rdpData[hour]++;
                    }
                });
            } else if (filterValue === 'thisWeek') {
                // Show last 7 days
                timeLabels = Array.from({length: 7}, (_, i) => {
                    const d = new Date(now);
                    d.setDate(d.getDate() - (6 - i));
                    return formatDate(d);
                });
                
                sshData = new Array(7).fill(0);
                telnetData = new Array(7).fill(0);
                ftpData = new Array(7).fill(0);
                smtpData = new Array(7).fill(0);
                rdpData = new Array(7).fill(0);

                sortedAttempts.forEach(attempt => {
                    const date = new Date(attempt.timestamp + 'Z');
                    const daysAgo = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                    if (daysAgo < 7) {
                        const dayIndex = 6 - daysAgo;
                        if (attempt.protocol === 'ssh') sshData[dayIndex]++;
                        else if (attempt.protocol === 'telnet') telnetData[dayIndex]++;
                        else if (attempt.protocol === 'ftp') ftpData[dayIndex]++;
                        else if (attempt.protocol === 'smtp') smtpData[dayIndex]++;
                        else if (attempt.protocol === 'rdp') rdpData[dayIndex]++;
                    }
                });
            } else {
                // All time - dynamically adjust time frame based on data span
                const oldestDate = sortedAttempts.length > 0 ? 
                    new Date(sortedAttempts[0].timestamp + 'Z') : now;
                const newestDate = sortedAttempts.length > 0 ?
                    new Date(sortedAttempts[sortedAttempts.length - 1].timestamp + 'Z') : now;
                const hoursDiff = Math.floor((newestDate - oldestDate) / (1000 * 60 * 60));
                
                // Choose appropriate time frame based on data span
                if (hoursDiff < 24) {
                    // If less than 24 hours of data, show hourly intervals
                    const startHour = oldestDate.getHours();
                    const endHour = newestDate.getHours();
                    const hoursToShow = endHour >= startHour ? 
                        (endHour - startHour + 1) : 
                        (24 - startHour + endHour + 1);
                    
                    timeLabels = Array.from({length: hoursToShow}, (_, i) => {
                        const hour = (startHour + i) % 24;
                        return formatHour(hour);
                    });
                    
                    sshData = new Array(hoursToShow).fill(0);
                    telnetData = new Array(hoursToShow).fill(0);
                    ftpData = new Array(hoursToShow).fill(0);
                    smtpData = new Array(hoursToShow).fill(0);
                    rdpData = new Array(hoursToShow).fill(0);

                    sortedAttempts.forEach(attempt => {
                        const date = new Date(attempt.timestamp + 'Z');
                        const hour = date.getHours();
                        const index = hour >= startHour ? 
                            (hour - startHour) : 
                            (24 - startHour + hour);
                        
                        if (index >= 0 && index < hoursToShow) {
                            if (attempt.protocol === 'ssh') sshData[index]++;
                            else if (attempt.protocol === 'telnet') telnetData[index]++;
                            else if (attempt.protocol === 'ftp') ftpData[index]++;
                            else if (attempt.protocol === 'smtp') smtpData[index]++;
                            else if (attempt.protocol === 'rdp') rdpData[index]++;
                        }
                    });
                } else if (hoursDiff < 168) { // Less than 7 days
                    // Show data by day with hours
                    const days = Math.ceil(hoursDiff / 24);
                    timeLabels = Array.from({length: days}, (_, i) => {
                        const d = new Date(oldestDate);
                        d.setDate(d.getDate() + i);
                        return formatDate(d);
                    });
                    
                    sshData = new Array(days).fill(0);
                    telnetData = new Array(days).fill(0);
                    ftpData = new Array(days).fill(0);
                    smtpData = new Array(days).fill(0);
                    rdpData = new Array(days).fill(0);

                    sortedAttempts.forEach(attempt => {
                        const date = new Date(attempt.timestamp + 'Z');
                        const dayIndex = Math.floor((date - oldestDate) / (1000 * 60 * 60 * 24));
                        if (dayIndex >= 0 && dayIndex < days) {
                            if (attempt.protocol === 'ssh') sshData[dayIndex]++;
                            else if (attempt.protocol === 'telnet') telnetData[dayIndex]++;
                            else if (attempt.protocol === 'ftp') ftpData[dayIndex]++;
                            else if (attempt.protocol === 'smtp') smtpData[dayIndex]++;
                            else if (attempt.protocol === 'rdp') rdpData[dayIndex]++;
                        }
                    });
                } else {
                    // More than 7 days - show up to 30 days
                    const daysDiff = Math.min(29, Math.floor((now - oldestDate) / (1000 * 60 * 60 * 24)));
                    timeLabels = Array.from({length: daysDiff + 1}, (_, i) => {
                        const d = new Date(now);
                        d.setDate(d.getDate() - (daysDiff - i));
                        return formatDate(d);
                    });
                    
                    sshData = new Array(daysDiff + 1).fill(0);
                    telnetData = new Array(daysDiff + 1).fill(0);
                    ftpData = new Array(daysDiff + 1).fill(0);
                    smtpData = new Array(daysDiff + 1).fill(0);
                    rdpData = new Array(daysDiff + 1).fill(0);

                    sortedAttempts.forEach(attempt => {
                        const date = new Date(attempt.timestamp + 'Z');
                        const daysAgo = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                        if (daysAgo <= daysDiff) {
                            const dayIndex = daysDiff - daysAgo;
                            if (attempt.protocol === 'ssh') sshData[dayIndex]++;
                            else if (attempt.protocol === 'telnet') telnetData[dayIndex]++;
                            else if (attempt.protocol === 'ftp') ftpData[dayIndex]++;
                            else if (attempt.protocol === 'smtp') smtpData[dayIndex]++;
                            else if (attempt.protocol === 'rdp') rdpData[dayIndex]++;
                        }
                    });
                }
            }

            // Update the attempts chart
            attemptsChart.data.labels = timeLabels;
            attemptsChart.data.datasets[0].data = sshData;
            attemptsChart.data.datasets[1].data = telnetData;
            attemptsChart.data.datasets[2].data = ftpData;
            attemptsChart.data.datasets[3].data = smtpData;
            attemptsChart.data.datasets[4].data = rdpData;
            attemptsChart.update();

            // Update username distribution chart
            const usernameData = {};
            filteredAttempts.forEach(attempt => {
                if (!usernameData[attempt.username]) {
                    usernameData[attempt.username] = { ssh: 0, telnet: 0, ftp: 0, smtp: 0, rdp: 0 };
                }
                if (attempt.protocol === 'ssh') {
                    usernameData[attempt.username].ssh++;
                } else if (attempt.protocol === 'telnet') {
                    usernameData[attempt.username].telnet++;
                } else if (attempt.protocol === 'ftp') {
                    usernameData[attempt.username].ftp++;
                } else if (attempt.protocol === 'smtp') {
                    usernameData[attempt.username].smtp++;
                } else if (attempt.protocol === 'rdp') {
                    usernameData[attempt.username].rdp++;
                }
            });

            const topUsernames = Object.entries(usernameData)
                .sort((a, b) => (b[1].ssh + b[1].telnet + b[1].ftp + b[1].smtp + b[1].rdp) - (a[1].ssh + a[1].telnet + a[1].ftp + a[1].smtp + a[1].rdp))
                .slice(0, 5);

            usernamesChart.data.labels = topUsernames.map(([username]) => username);
            usernamesChart.data.datasets[0].data = topUsernames.map(([, counts]) => counts.ssh);
            usernamesChart.data.datasets[1].data = topUsernames.map(([, counts]) => counts.telnet);
            usernamesChart.data.datasets[2].data = topUsernames.map(([, counts]) => counts.ftp);
            usernamesChart.data.datasets[3].data = topUsernames.map(([, counts]) => counts.smtp);
            usernamesChart.data.datasets[4].data = topUsernames.map(([, counts]) => counts.rdp);
            usernamesChart.update();

            // Update IP addresses chart
            const ipData = {};
            filteredAttempts.forEach(attempt => {
                ipData[attempt.client_ip] = (ipData[attempt.client_ip] || 0) + 1;
            });

            const topIPs = Object.entries(ipData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            ipsChart.data.labels = topIPs.map(([ip]) => ip);
            ipsChart.data.datasets[0].data = topIPs.map(([, count]) => count);
            ipsChart.update();

            // Update countries chart
            const countryData = {};
            filteredAttempts.forEach(attempt => {
                if (attempt.country) {
                    countryData[attempt.country] = (countryData[attempt.country] || 0) + 1;
                }
            });

            const topCountries = Object.entries(countryData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            countriesChart.data.labels = topCountries.map(([country]) => country);
            countriesChart.data.datasets[0].data = topCountries.map(([, count]) => count);
            countriesChart.update();
        }

        // Add pagination event listeners
        document.getElementById('prevPage').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                updateUI();
            }
        });

        document.getElementById('nextPage').addEventListener('click', () => {
            const filteredAttempts = filterAttempts(attempts);
            const totalPages = Math.ceil(filteredAttempts.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                updateUI();
            }
        });

        // Modify existing event listeners to reset pagination
        searchInput.addEventListener('input', () => {
            currentPage = 1;
            updateUI();
        });
        
        filterSelect.addEventListener('change', () => {
            currentPage = 1;
            updateUI();
        });

        protocolSelect.addEventListener('change', () => {
            currentPage = 1;
            updateUI();
        });

        // Initialize chart configurations with responsive design
        const attemptsChart = new Chart(
            document.getElementById('attemptsChart'),
            {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'SSH',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark') 
                                ? '#8b5cf6'  // Purple for dark mode
                                : '#6d28d9',  // Darker purple for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'Telnet',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark')
                                ? '#3b82f6'  // Blue for dark mode
                                : '#2563eb',  // Darker blue for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'FTP',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark')
                                ? '#10b981'  // Green for dark mode
                                : '#059669',  // Darker green for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'SMTP',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark')
                                ? '#f59e0b'  // Amber for dark mode
                                : '#d97706',  // Darker amber for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        },
                        {
                            label: 'RDP',
                            data: [],
                            borderColor: document.documentElement.classList.contains('dark')
                                ? '#ec4899'  // Pink for dark mode
                                : '#db2777',  // Darker pink for light mode
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            }
                        },
                        title: {
                            display: false
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            }
        );

        const usernamesChart = new Chart(
            document.getElementById('usernamesChart'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'SSH',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(139, 92, 246, 0.8)'   // Purple with opacity for dark mode
                                : 'rgba(109, 40, 217, 0.8)',  // Darker purple with opacity for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'Telnet',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(59, 130, 246, 0.8)'  // Blue with opacity for dark mode
                                : 'rgba(37, 99, 235, 0.8)',  // Darker blue with opacity for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'FTP',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(16, 185, 129, 0.8)'  // Green with opacity for dark mode
                                : 'rgba(5, 150, 105, 0.8)',  // Darker green with opacity for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'SMTP',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(245, 158, 11, 0.8)'  // Amber with opacity for dark mode
                                : 'rgba(217, 119, 6, 0.8)',  // Darker amber with opacity for light mode
                            borderRadius: 4
                        },
                        {
                            label: 'RDP',
                            data: [],
                            backgroundColor: document.documentElement.classList.contains('dark')
                                ? 'rgba(236, 72, 153, 0.8)'  // Pink with opacity for dark mode
                                : 'rgba(219, 39, 119, 0.8)',  // Darker pink with opacity for light mode
                            borderRadius: 4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            stacked: true,
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            }
                        }
                    }
                }
            }
        );

        // Initialize new chart for IP addresses
        const ipsChart = new Chart(
            document.getElementById('ipsChart'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: document.documentElement.classList.contains('dark')
                            ? 'rgba(139, 92, 246, 0.8)'
                            : 'rgba(109, 40, 217, 0.8)',
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Attempts: ${context.raw}`;
                                }
                            }
                        }
                    }
                }
            }
        );

        // Initialize new chart for countries
        const countriesChart = new Chart(
            document.getElementById('countriesChart'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: document.documentElement.classList.contains('dark')
                            ? 'rgba(59, 130, 246, 0.8)'
                            : 'rgba(37, 99, 235, 0.8)',
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937'
                            },
                            grid: {
                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Attempts: ${context.raw}`;
                                }
                            }
                        }
                    }
                }
            }
        );

        // Initialize WebSocket connection for real-time updates
        connectWebSocket();

        // Expo
        document.getElementById('exportIPs').addEventListener('click', () => {
            // Open in new tab
            window.open('/api/export/ips', '_blank');
        });

        // Hamburger Menu
        document.getElementById('hamburgerBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const mobileMenu = document.getElementById('mobileMenu');
            const isHidden = mobileMenu.classList.contains('hidden');
            
            // Toggle menu visibility
            mobileMenu.classList.toggle('hidden');
            
            // Handle overlay
            if (!mobileMenu.classList.contains('hidden')) {
                // Add overlay if menu is visible
                const overlay = document.createElement('div');
                overlay.className = 'menu-overlay';
                document.body.appendChild(overlay);
                
                // Ensure overlay is visible after being added to DOM
                requestAnimationFrame(() => {
                    overlay.classList.add('active');
                });
            } else {
                // Remove overlay if menu is hidden
                const overlay = document.querySelector('.menu-overlay');
                if (overlay) {
                    overlay.classList.remove('active');
                    setTimeout(() => overlay.remove(), 300);
                }
            }
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const mobileMenu = document.getElementById('mobileMenu');
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            
            if (!mobileMenu.contains(e.target) && !hamburgerBtn.contains(e.target)) {
                mobileMenu.classList.add('hidden');
                const overlay = document.querySelector('.menu-overlay');
                if (overlay) {
                    overlay.classList.remove('active');
                    setTimeout(() => overlay.remove(), 300);
                }
            }
        });

        // Close menu when clicking inside
        document.getElementById('mobileMenu').addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Menu item click handlers
        document.getElementById('exportIPsMenu').addEventListener('click', () => {
            document.getElementById('mobileMenu').classList.add('hidden');
            const overlay = document.querySelector('.menu-overlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => overlay.remove(), 300);
            }
            window.open('/api/export/ips', '_blank');
        });

        document.getElementById('darkModeToggleMenu').addEventListener('click', () => {
            document.getElementById('mobileMenu').classList.add('hidden');
            const overlay = document.querySelector('.menu-overlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => overlay.remove(), 300);
            }
        });

        // FAQ Modal
        document.getElementById('faqButton').addEventListener('click', () => {
            document.getElementById('mobileMenu').classList.add('hidden');
            const overlay = document.querySelector('.menu-overlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => overlay.remove(), 300);
            }
            document.getElementById('faqModal').classList.remove('hidden');
        });

        document.getElementById('closeFaqModal').addEventListener('click', () => {
            document.getElementById('faqModal').classList.add('hidden');
        });

        // Close FAQ modal when clicking outside
        document.getElementById('faqModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('faqModal')) {
                document.getElementById('faqModal').classList.add('hidden');
            }
        });

        // Close modals on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const mobileMenu = document.getElementById('mobileMenu');
                const faqModal = document.getElementById('faqModal');
                const overlay = document.querySelector('.menu-overlay');
                
                if (!mobileMenu.classList.contains('hidden')) {
                    mobileMenu.classList.add('hidden');
                    if (overlay) {
                        overlay.classList.remove('active');
                        setTimeout(() => overlay.remove(), 300);
                    }
                }
                
                if (!faqModal.classList.contains('hidden')) {
                    faqModal.classList.add('hidden');
                }
            }
        });
    </script>
</body>
</html> 